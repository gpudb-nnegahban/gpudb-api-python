##############################################
# Autogenerated GPUdb Python API file. 
# 
# *****Do NOT modify this file***** 
# 
##############################################

# ---------------------------------------------------------------------------
# gpudb.py - The Python API to interact with a GPUdb server. 
#
# Copyright (c) 2014 GIS Federal
# ---------------------------------------------------------------------------

import cStringIO, StringIO
import base64, httplib
import os, sys
import json
import uuid

# ---------------------------------------------------------------------------
# The absolute path of this gpudb.py module for importing local packages
gpudb_module_path = __file__
if gpudb_module_path[len(gpudb_module_path)-3:] == "pyc": # allow symlinks to gpudb.py
    gpudb_module_path = gpudb_module_path[0:len(gpudb_module_path)-1]
if os.path.islink(gpudb_module_path): # allow symlinks to gpudb.py
    gpudb_module_path = os.readlink(gpudb_module_path)
gpudb_module_path = os.path.dirname(os.path.abspath(gpudb_module_path))

# Search for our modules first, probably don't need imp or virt envs.
if not gpudb_module_path + "/packages" in sys.path :
    sys.path.insert(1, gpudb_module_path + "/packages")

# ---------------------------------------------------------------------------
# Local imports after adding our module search path
from avro import schema, datafile, io


if sys.version_info >= (2, 7):
    import collections
else:
    import ordereddict as collections # a separate package

have_snappy = False
try:
    import snappy
    have_snappy = True
except ImportError:
    have_snappy = False

from tabulate import tabulate

# ---------------------------------------------------------------------------
# GPUdb - Lightweight client class to interact with a GPUdb server.
# ---------------------------------------------------------------------------

class GPUdb:

    def __init__(self, host="127.0.0.1", port="9191",
                       encoding="BINARY", connection='HTTP',
                       username="", password=""):
        """
        Construct a new GPUdb client instance.

        Parameters:
            host    : The IP address of the GPUdb server.
            port  : The port of the GPUdb server at the given IP address.
            encoding   : Type of Avro encoding to use, "BINARY", "JSON" or "SNAPPY".
            connection : Connection type, currently only "HTTP" or "HTTPS" supported.
            username   : An optional http username.
            password   : The http password for the username.
        """

        assert (type(host) is str), "Expected a string host address, got: '"+str(host)+"'"

        # host may take the form of :
        #  - "https://user:password@domain.com:port/path/"

        if host.startswith("http://") :    # Allow http://, but remove it.
            host = host[7:]
        elif host.startswith("https://") : # Allow https://, but remove it.
            host = host[8:]
            connection = "HTTPS" # force it

        # Parse the username and password, if supplied.
        host_at_sign_pos = host.find('@')
        if host_at_sign_pos != -1 :
            user_pass = host[:host_at_sign_pos]
            host = host[host_at_sign_pos+1:]
            user_pass_list = user_pass.split(':')
            username = user_pass_list[0]
            if len(user_pass_list) > 1 :
                password = user_pass_list[1]

        url_path = ""
        # Find the URL /path/ and remove it to get the ip address.
        host_path_pos = host.find('/')
        if host_path_pos != -1:
            url_path = host[host_path_pos:]
            if url_path[-1] == '/':
                url_path = url_path[:-1]
            host = host[:host_path_pos]

        # Override default port if specified in ip address
        host_port_pos = host.find(':')
        if host_port_pos != -1 :
            port = host[host_port_pos+1:]
            host = host[:host_port_pos]

        # Port does not have to be provided if using standard HTTP(S) ports.
        if (port == None) or len(str(port)) == 0:
            if connection == 'HTTP' :
                port = 80
            elif connection == 'HTTPS' :
                port = 443

        # Validate port
        try :
            port = int(port)
        except :
            assert False, "Expected a numeric port, got: '" + str(port) + "'"

        assert (port > 0) and (port < 65536), "Expected a valid port (1-65535), got: '"+str(port)+"'"
        assert (len(host) > 0), "Expected a valid host address, got an empty string."
        assert (encoding in ["BINARY", "JSON", "SNAPPY"]), "Expected encoding to be either 'BINARY', 'JSON' or 'SNAPPY' got: '"+str(encoding)+"'"
        assert (connection in ["HTTP", "HTTPS"]), "Expected connection to be 'HTTP' or 'HTTPS', got: '"+str(connection)+"'"

        if (encoding == 'SNAPPY' and not have_snappy):
            print 'SNAPPY encoding specified but python-snappy is not installed; reverting to BINARY'
            encoding = 'BINARY'

        self.host       = host
        self.port       = int(port)
        self.encoding   = encoding
        self.connection = connection
        self.username   = username
        self.password   = password
        self.gpudb_url_path = url_path


        self.client_to_object_encoding_map = { \
                                               "BINARY": "binary",
                                               "SNAPPY": "binary",
                                               "JSON": "json",
        }

        # Load all gpudb schemas
        self.load_gpudb_schemas()
    # end __init__


    # members
    host       = "127.0.0.1" # Input host with port appended if provided.
    gpudb_url_path = ""          # Input /path (if any) that was in the host.
    port     = "9191"      # Input port, may be empty.
    encoding      = "BINARY"    # Input encoding, either 'BINARY' or 'JSON'.
    connection    = "HTTP"      # Input connection type, either 'HTTP' or 'HTTPS'.
    username      = ""          # Input username or empty string for none.
    password      = ""          # Input password or empty string for none.

    # constants
    END_OF_SET = -9999

    # schemas for common data types
    point_schema_str = """{"type":"record","name":"point","fields":[{"name":"x","type":"double"},{"name":"y","type":"double"},{"name":"OBJECT_ID","type":"string"}]}"""
    big_point_schema_str = """{"type":"record","name":"point","fields":[{"name":"msg_id","type":"string"},{"name":"x","type":"double"},{"name":"y","type":"double"},{"name":"TIMESTAMP","type":"double"},{"name":"source","type":"string"},{"name":"group_id","type":"string"},{"name":"OBJECT_ID","type":"string"}]}"""
    gis_point_schema_str = """{"type":"record","name":"Point","fields":[{"name":"x","type":"double"},{"name":"y","type":"double"},{"name":"timestamp","type":"double"},{"name":"tag_id","type":"double"},{"name":"derived","type":"double"},{"name":"msg_id","type":"string"},{"name":"group_id","type":"string"},{"name":"level_one_mgrs","type":"string"},{"name":"level_two_mgrs","type":"string"},{"name":"level_three_mgrs","type":"string"},{"name":"level_final_mgrs","type":"string"},{"name":"OBJECT_ID","type":"string"}]}"""
    bytes_point_schema_str = """{"type":"record","name":"point","fields":[{"name":"msg_id","type":"string"},{"name":"x","type":"double"},{"name":"y","type":"double"},{"name":"timestamp","type":"int"},{"name":"source","type":"string"},{"name":"group_id","type":"string"},{"name":"bytes_data","type":"bytes"},{"name":"OBJECT_ID","type":"string"}]}"""
    bigger_point_schema_str = """{"type":"record","name":"point","fields":[{"name":"ARTIFACTID","type":"string"},{"name":"x","type":"double"},{"name":"y","type":"double"},{"name":"TIMESTAMP","type":"double"},{"name":"DATASOURCE","type":"string"},{"name":"DATASOURCESUB","type":"string"},{"name":"OBJECTAUTH", "type" : "string"},{"name": "AUTHOR", "type":"string"},{"name":"DATASOURCEKEY","type":"string"},{"name":"OBJECT_ID","type":"string"}]}"""
    twitter_point_schema_str = """{"type":"record","name":"point","fields":[{"name":"ARTIFACTID","type":"string"},{"name":"x","type":"double"},{"name":"y","type":"double"},{"name":"TIMESTAMP","type":"double"},{"name":"DATASOURCE","type":"string"},{"name":"DATASOURCESUB","type":"string"},{"name":"KEYWORD","type":"string"},{"name":"OBJECTAUTH", "type" : "string"},{"name": "AUTHOR", "type":"string"},{"name":"DATASOURCEKEY","type":"string"},{"name":"OBJECT_ID","type":"string"}]}"""

    # Some other schemas for internal work
    logger_request_schema_str = """
        {
            "type" : "record", 
            "name" : "logger_request",
            "fields" : [
                {"name" : "ranks", "type" : {"type" : "array", "items" : "int"}},
                {"name" : "log_levels", "type" : {"type" : "map", "values" : "string"}}
            ]
        }
    """.replace("\n", "").replace(" ", "")
    logger_response_schema_str = """
        {
            "type" : "record", 
            "name" : "logger_response",
            "fields" : [
                {"name" : "status" , "type" : "string"},
                {"name" : "log_levels", "type" : {"type" : "map", "values" : "string"}}
            ]
        }
    """.replace("\n", "").replace(" ", "")

    # Parse common schemas, others parsed on demand.
    point_schema = schema.parse(point_schema_str)
    big_point_schema = schema.parse(big_point_schema_str)
    gis_point_schema = None # schema.parse(gis_point_schema_str)
    bytes_point_schema = None # schema.parse(bytes_point_schema_str)
    bigger_point_schema = None # schema.parse(bigger_point_schema_str)
    twitter_point_schema = schema.parse(twitter_point_schema_str)

    # -----------------------------------------------------------------------
    # Helper functions
    # -----------------------------------------------------------------------

    def post_to_gpudb_read(self, body_data, endpoint):
        """
        Create a HTTP connection and POST then get GET, returning the server response.

        Parameters:
            body_data : Data to POST to GPUdb server.
            endpoint  : Server path to POST to, e.g. "/add".
        """

        if self.encoding == 'BINARY':
            headers = {"Content-type": "application/octet-stream",
                       "Accept": "application/octet-stream"}
        elif self.encoding == 'JSON':
            headers = {"Content-type": "application/json",
                       "Accept": "application/json"}
        elif self.encoding == 'SNAPPY':
            headers = {"Content-type": "application/x-snappy",
                       "Accept": "application/x-snappy"}
            body_data = snappy.compress(body_data)

        if len(self.username) != 0:
            # base64 encode the username and password
            auth = base64.encodestring('%s:%s' % (self.username, self.password)).replace('\n', '')
            headers["Authorization"] = ("Basic %s" % auth)

        # NOTE: Creating a new httplib.HTTPConnection is suprisingly just as
        #       fast as reusing a persistent one and has the advantage of
        #       fully retrying from scratch if the connection fails.

        try:
            if (self.connection == 'HTTP'):
                conn = httplib.HTTPConnection(host=self.host, port=self.port)
            elif (self.connection == 'HTTPS'):
                conn = httplib.HTTPSConnection(host=self.host, port=self.port)
            else:
                assert False, "Unknown connection type, should be 'HTTP' or 'HTTPS'"
        except:
            print("Error connecting to: '%s' on port %d" % (self.host, self.port))
            raise

        try:
            conn.request("POST", self.gpudb_url_path+endpoint, body_data, headers)
        except:
            print("Error posting to: '%s:%d%s'" % (self.host, self.port, self.gpudb_url_path+endpoint))
            raise

        try:
            resp = conn.getresponse()
            resp_data = resp.read()
            #print 'data received: ',len(resp_data)
            #print 'headers received: ',resp.getheaders()
            resp_time = resp.getheader('x-request-time-secs',None)
        except: # some error occurred; return a message
            # TODO: Maybe use a class like GPUdbException
            raise ValueError( "Timeout Error: No response received from %s" % self.host )
        # end except

        # resp = conn.getresponse()
        # #Print resp.status,resp.reason
        # resp_data = resp.read() # TODO: comment this out
        # #print("response size: %d"   % (len(resp_data)))
        # #print("response     : '%s'" % (resp_data))

        return  str(resp_data),resp_time

    def write_datum(self, SCHEMA, datum):
        """
        Returns an avro binary or JSON encoded dataum dict using its schema.

        Parameters:
            SCHEMA : A parsed schema from avro.schema.parse().
            datum  : A dict of key-value pairs matching the schema.
        """

        # build the encoder; this output is where the data will be written
        if self.encoding == 'BINARY' or self.encoding == 'SNAPPY':
            output = cStringIO.StringIO()
            be = io.BinaryEncoder(output)

            # Create a 'record' (datum) writer
            writer = io.DatumWriter(SCHEMA)
            writer.write(datum, be)

            return output.getvalue()

        elif self.encoding == 'JSON':

            data_str = json.dumps(datum)

            return data_str

    def encode_datum(self, schema_str, datum):
        OBJ_SCHEMA = schema.parse(schema_str)

        return self.write_datum(OBJ_SCHEMA, datum)


    def client_to_object_encoding( self ):
        """Returns object encoding for queries based on the GPUdb client's
        encoding.
        """
        return self.client_to_object_encoding_map[ self.encoding ]
    # end client_to_object_encoding

    def read_orig_datum(self, SCHEMA, encoded_datum, encoding=None):
        """
        Decode the binary or JSON encoded datum using the avro schema and return a dict.

        Parameters:
            SCHEMA        : A parsed schema from avro.schema.parse().
            encoded_datum : Binary or JSON encoded data.
            encoding      : Type of avro encoding, either "BINARY" or "JSON",
                            None uses the encoding this class was initialized with.
        """
        if encoding == None:
            encoding = self.encoding

        if (encoding == 'BINARY') or (encoding == 'SNAPPY'):
            output = cStringIO.StringIO(encoded_datum)
            bd = io.BinaryDecoder(output)
            reader = io.DatumReader(SCHEMA)
            out = reader.read(bd) # read, give a decoder

            return out
        elif encoding == 'JSON':
            data_str = json.loads(encoded_datum.replace('\\U','\\u'))

            return data_str


    def read_datum(self, SCHEMA, encoded_datum, encoding=None, response_time=None):
        """
        Decode a gpudb_response and decode the contained message too.

        Parameters:
            SCHEMA : The parsed schema from avro.schema.parse() that the gpudb_response contains.
            encoded_datum : A BINARY or JSON encoded gpudb_response message.
        Returns:
            An OrderedDict of the decoded gpudb_response message's data with the
            gpudb_response put into the "status_info" field.
        """

        # Parse the gpudb_response message
        REP_SCHEMA = self.gpudb_schemas["gpudb_response"]["RSP_SCHEMA"]
        resp = self.read_orig_datum(REP_SCHEMA, encoded_datum, encoding)

        #now parse the actual response if there is no error
        #NOTE: DATA_SCHEMA should be equivalent to SCHEMA but is NOT for get_set_sorted
        stype = resp['data_type']
        if stype == 'none':
            out = collections.OrderedDict()
        else:
            if self.encoding == 'JSON':
                out = self.read_orig_datum(SCHEMA, resp['data_str'], 'JSON')
            elif (self.encoding == 'BINARY') or (self.encoding == 'SNAPPY'):
                out = self.read_orig_datum(SCHEMA, resp['data'], 'BINARY')

        del resp['data']
        del resp['data_str']

        out['status_info'] = resp

        if (response_time is not None):
            out['status_info']['response_time'] = float(response_time)

        return out

    def get_schemas(self, base_name):
        """
        Get a tuple of parsed and cached request and reply schemas.

        Parameters:
            base_name : Schema name, e.g. "base_name"+"_request.json" or "_response.json"
        """
        REQ_SCHEMA = self.gpudb_schemas[base_name]["REQ_SCHEMA"]
        RSP_SCHEMA = self.gpudb_schemas[base_name]["RSP_SCHEMA"]
        return (REQ_SCHEMA, RSP_SCHEMA)


    def post_then_get(self, REQ_SCHEMA, REP_SCHEMA, datum, endpoint):
        """
        Encode the datum dict using the REQ_SCHEMA, POST to GPUdb server and
        decode the reply using the REP_SCHEMA.

        Parameters:
            REQ_SCHEMA : The parsed schema from avro.schema.parse() of the request.
            REP_SCHEMA : The parsed schema from avro.schema.parse() of the reply.
            datum      : Request dict matching the REQ_SCHEMA.
            endpoint   : Server path to POST to, e.g. "/add".
        """
        encoded_datum = self.write_datum(REQ_SCHEMA, datum)
        response,response_time  = self.post_to_gpudb_read(encoded_datum, endpoint)

        return self.read_datum(REP_SCHEMA, response, None, response_time)

    # ------------- Convenience Functions ------------------------------------

    def read_point(self, encoded_datum, encoding=None):
        if self.point_schema is None:
            self.point_schema = schema.parse(self.point_schema_str)

        return self.read_orig_datum(self.point_schema, encoded_datum, encoding)

    def read_big_point(self, encoded_datum, encoding=None):
        if self.big_point_schema is None:
            self.big_point_schema = schema.parse(self.big_point_schema_str)

        return self.read_orig_datum(self.big_point_schema, encoded_datum, encoding)

    def read_gis_point(self, encoded_datum, encoding=None):
        # this point is designed to look like "Point"

        if self.gis_point_schema is None:
            self.gis_point_schema = schema.parse(self.gis_point_schema_str)

        return self.read_orig_datum(self.gis_point_schema, encoded_datum, encoding)

    def read_trigger_msg(self, encoded_datum):
        RSP_SCHEMA = self.gpudb_schemas[ "trigger_notification" ]["RSP_SCHEMA"]
        return self.read_orig_datum(RSP_SCHEMA, encoded_datum, 'BINARY')


    def logger(self, ranks, log_levels):
        """Convenience function to change log levels of some
        or all GPUdb ranks.
        """
        REQ_SCHEMA     = schema.parse( self.logger_request_schema_str )
        REP_SCHEMA     = schema.parse( self.logger_response_schema_str )

        datum = collections.OrderedDict()
        datum["ranks"]      = ranks
        datum["log_levels"] = log_levels

        print('Using host: %s\n' % (self.host))
        return self.post_then_get(REQ_SCHEMA, REP_SCHEMA, datum, "/logger")
    # end logger

    # ------------------ Type registration functions for convenient types ------

    def register_type_big_point(self):
        (REQ_SCHEMA,REP_SCHEMA) = self.get_schemas("create_type")

        datum = collections.OrderedDict()
        datum["type_definition"] = self.big_point_schema_str
        #datum["annotation"] = "msg_id"
        datum["label"] = "big_point_type"
        datum["properties"] = {}
        datum["options"] = {}

        return self.post_then_get(REQ_SCHEMA, REP_SCHEMA, datum, "/create/type")

    def register_type_bigger_point(self):
        (REQ_SCHEMA,REP_SCHEMA) = self.get_schemas("create_type")

        datum = collections.OrderedDict()
        datum["type_definition"] = self.bigger_point_schema_str
        #datum["annotation"] = "ARTIFACTID"
        datum["label"] = "bigger_point_type"
        datum["properties"] = {}
        datum["options"] = {}

        return self.post_then_get(REQ_SCHEMA, REP_SCHEMA, datum, "/create/type")

    def register_type_bytes_point(self):
        (REQ_SCHEMA,REP_SCHEMA) = self.get_schemas("create_type")

        datum = collections.OrderedDict()
        datum["type_definition"] = self.bytes_point_schema_str
        #datum["annotation"] = "msg_id"
        datum["label"] = "bytes_point_type"
        datum["properties"] = {}
        datum["options"] = {}

        return self.post_then_get(REQ_SCHEMA, REP_SCHEMA, datum, "/create/type")

    def register_type_gis_point(self):
        (REQ_SCHEMA,REP_SCHEMA) = self.get_schemas("create_type")

        datum = collections.OrderedDict()
        datum["type_definition"] = self.gis_point_schema_str
        #datum["annotation"] = "msg_id"
        datum["label"] = "gis_point_type"
        datum["properties"] = {}
        datum["options"] = {}

        return self.post_then_get(REQ_SCHEMA, REP_SCHEMA, datum, "/create/type")

    def register_type_point(self):
        (REQ_SCHEMA,REP_SCHEMA) = self.get_schemas("create_type")

        datum = collections.OrderedDict()
        datum["type_definition"] = self.point_schema_str
        #datum["annotation"] = ""
        datum["label"] = "basic_point_type"
        datum["properties"] = {}
        datum["options"] = {}

        return self.post_then_get(REQ_SCHEMA, REP_SCHEMA, datum, "/create/type")

    def register_type_twitter_point(self):
        (REQ_SCHEMA,REP_SCHEMA) = self.get_schemas("create_type")

        datum = collections.OrderedDict()
        datum["type_definition"] = self.twitter_point_schema_str
        #datum["annotation"] = "ARTIFACTID"
        datum["label"] = "twitter_point_type"
        datum["properties"] = {}
        datum["options"] = {}

        return self.post_then_get(REQ_SCHEMA, REP_SCHEMA, datum, "/create/type")

    # ------------------ Add functions for convenient types -----------------------------

    def add_big_point(self, set_id, msg_id, x, y, timestamp, source, group_id, OBJECT_ID=''):
        if self.big_point_schema is None:
            self.big_point_schema = schema.parse(self.big_point_schema_str)

        obj_list_encoded = []

        datum = collections.OrderedDict()
        datum["msg_id"] = msg_id
        datum["x"] = x
        datum["y"] = y
        datum["TIMESTAMP"] = timestamp
        datum["source"] = source
        datum["group_id"] = group_id
        datum["OBJECT_ID"] = OBJECT_ID

        obj_list_encoded.append(self.write_datum(self.big_point_schema, datum))

        return self.insert_records(set_id, obj_list_encoded, None, {"return_record_ids":"true"})

    def add_bigger_point(self, set_id, artifact_id, x, y, timestamp, OBJECT_ID=''):
        if self.bigger_point_schema is None:
            self.bigger_point_schema = schema.parse(self.bigger_point_schema_str)

        obj_list_encoded = []

        datum = collections.OrderedDict()
        datum["ARTIFACTID"] = artifact_id
        datum["x"] = x
        datum["y"] = y
        datum["TIMESTAMP"] = timestamp
        datum["DATASOURCE"] = "OSC"
        datum["DATASOURCESUB"] = "REPLICATED"
        datum["DATASOURCEKEY"] = "OSC:REPLICATED"
        datum["AUTHOR"] = "OSC"
        datum["OBJECTAUTH"] = "U"
        datum["OBJECT_ID"] = OBJECT_ID

        obj_list_encoded.append(self.write_datum(self.bigger_point_schema, datum))

        return self.insert_records(set_id, obj_list_encoded, None, {"return_record_ids":"true"})


    def add_bytes_point(self, set_id, msg_id, x, y, timestamp, source, group_id, bytes_data, OBJECT_ID=''):
        if self.bytes_point_schema is None:
            self.bytes_point_schema = schema.parse(self.bytes_point_schema_str)

        obj_list_encoded = []

        datum = collections.OrderedDict()
        datum["msg_id"] = msg_id
        datum["x"] = x
        datum["y"] = y
        datum["timestamp"] = timestamp
        datum["source"] = source
        datum["group_id"] = group_id
        datum["bytes_data"] = bytes_data
        datum["OBJECT_ID"] = OBJECT_ID

        obj_list_encoded.append(self.write_datum(self.bytes_point_schema, datum))

        return self.insert_records(set_id, obj_list_encoded, None, {"return_record_ids":"true"})


    def add_gis_point(self, set_id, msg_id, x, y, timestamp, tag_id, derived, group_id,
                         level_one_mgrs, level_two_mgrs, level_three_mgrs, level_final_mgrs, OBJECT_ID=''):
        if self.gis_point_schema is None:
            self.gis_point_schema = schema.parse(self.gis_point_schema_str)

        obj_list_encoded = []

        datum = collections.OrderedDict()

        datum["x"] = x
        datum["y"] = y
        datum["timestamp"] = timestamp
        datum["tag_id"] = tag_id
        datum["derived"] = derived
        datum["msg_id"] = msg_id
        datum["group_id"] = group_id
        datum["level_one_mgrs"] = level_one_mgrs
        datum["level_two_mgrs"] = level_two_mgrs
        datum["level_three_mgrs"] = level_three_mgrs
        datum["level_final_mgrs"] = level_final_mgrs
        datum["OBJECT_ID"] = OBJECT_ID

        obj_list_encoded.append(self.write_datum(self.gis_point_schema, datum))

        return self.insert_records(set_id, obj_list_encoded, None, {"return_record_ids":"true"})


    def add_point(self, set_id, x, y, OBJECT_ID=''):
        if self.point_schema is None:
            self.point_schema = schema.parse(self.point_schema_str)

        obj_list_encoded = []

        datum = collections.OrderedDict()
        datum['x'] = x
        datum['y'] = y
        datum['OBJECT_ID'] = OBJECT_ID

        obj_list_encoded.append(self.write_datum(self.point_schema, datum))

        return self.insert_records(set_id, obj_list_encoded, None, {"return_record_ids":"true"})

    # This assumes equal length lists
    def bulk_add_big_point(self, set_id, msg_id_list, x_list, y_list, timestamp_list, source_list, group_id_list, OBJECT_ID_list=None):
        if self.big_point_schema is None:
            self.big_point_schema = schema.parse(self.big_point_schema_str)

        if (OBJECT_ID_list is None):
            OBJECT_ID_list = ['' for x in x_list]

        obj_list_encoded = []

        for msg_id,x,y,timestamp,source,group_id,object_id in zip(msg_id_list,x_list,y_list,timestamp_list,source_list,group_id_list,OBJECT_ID_list):
            datum = collections.OrderedDict()
            datum['msg_id'] = msg_id
            datum['x'] = x
            datum['y'] = y
            datum['TIMESTAMP'] = timestamp
            datum['source'] = source
            datum['group_id'] = group_id
            datum['OBJECT_ID'] = object_id
            obj_list_encoded.append(self.write_datum(self.big_point_schema, datum))

        return self.insert_records(set_id, obj_list_encoded, None, {"return_record_ids":"true"})

    # This assumes that 'x' and 'y' are equal length lists
    def bulk_add_point(self, set_id, x_list, y_list, OBJECT_ID_list=None):
        if self.point_schema is None:
            self.point_schema = schema.parse(self.point_schema_str)

        if (OBJECT_ID_list is None):
            OBJECT_ID_list = ['' for x in x_list]

        obj_list_encoded = []

        for i in range(0,len(x_list)):
            datum = collections.OrderedDict()
            datum['x'] = x_list[i]
            datum['y'] = y_list[i]
            datum['OBJECT_ID'] = OBJECT_ID_list[i]
            obj_list_encoded.append(self.write_datum(self.point_schema, datum))

        return self.insert_records(set_id, obj_list_encoded, None, {"return_record_ids":"true"})

    # Helper function to emulate old /add (single object insert) capability
    def insert_object(self, set_id, object_data, params=None):
        if (params):
            return self.insert_records(set_id, [object_data], None, params)
        else:
            return self.insert_records(set_id, [object_data], None, {"return_record_ids":"true"})

    # Helper for dynamic schema responses
    def parse_dynamic_response(self, retobj, do_print=False):

        if (retobj['status_info']['status'] == 'ERROR'):
            print 'Error: ', retobj['status_info']['message']
            return retobj

        if len(retobj['binary_encoded_response']) > 0:
  
            my_schema = schema.parse(retobj['response_schema_str'])
            
            csio = cStringIO.StringIO(retobj['binary_encoded_response'])
            bd = io.BinaryDecoder(csio)
            reader = io.DatumReader(my_schema)
            decoded = reader.read(bd) # read, give a decoder

            #translate the column names
            column_lookup = decoded['column_headers']

            translated = collections.OrderedDict()
            for i,column_name in enumerate(column_lookup):
                translated[column_name] = decoded['column_%d'%(i+1)]

            retobj['response'] = translated
        else:
            retobj['response'] = collections.OrderedDict()

            #note running eval here returns a standard (unordered) dict
            d_resp = eval(retobj['json_encoded_response'])

            #now go through the fields in order according to the schema
            my_schema = schema.parse(retobj['response_schema_str'])

            column_lookup = d_resp['column_headers']

            for i,column_name in enumerate(column_lookup):
                retobj['response'][column_name] = d_resp['column_%d'%(i+1)]

        if (do_print):
            print tabulate(retobj['response'],headers='keys',tablefmt='psql')

        return retobj

    # ------------- END convenience functions ------------------------------------


    # ------------- BEGIN functions for GPUdb developers -----------------------

    # -----------------------------------------------------------------------
    # join -> /join

    def join(self, left_set, left_attr, right_set, right_attr, result_type, result_set, user_auth=""):
        (REQ_SCHEMA,REP_SCHEMA) = self.get_schemas("join")

        datum = collections.OrderedDict()
        datum["left_set"] = left_set
        datum["left_attr"] = left_attr
        datum["right_set"] = right_set
        datum["right_attr"] = right_attr
        datum["result_type"] = result_type
        datum["result_set"] = result_set
        datum["user_auth_string"] = user_auth

        return self.post_then_get(REQ_SCHEMA, REP_SCHEMA, datum, "/join")

    # -----------------------------------------------------------------------
    # join_incremental -> /joinincremental

    def join_incremental(self, left_subset, left_attr, left_index, right_set, right_attr, result_set, result_type, user_auth=""):
        (REQ_SCHEMA,REP_SCHEMA) = self.get_schemas("join_incremental")

        datum = collections.OrderedDict()
        datum["left_subset"] = left_subset
        datum["left_attr"] = left_attr
        datum["left_index"] = left_index
        datum["right_set"] = right_set
        datum["right_attr"] = right_attr
        datum["result_set"] = result_set
        datum["result_type"] = result_type
        datum["data_map"] = {}
        datum["user_auth_string"] = user_auth

        return self.post_then_get(REQ_SCHEMA, REP_SCHEMA, datum, "/joinincremental")

    # -----------------------------------------------------------------------
    # join_setup -> /joinsetup

    #initial join setup for the incremental join
    def join_setup(self, left_set, left_attr, right_set, right_attr, subset_id, user_auth=""):
        (REQ_SCHEMA,REP_SCHEMA) = self.get_schemas("join_setup")

        datum = collections.OrderedDict()
        datum["left_set"] = left_set
        datum["left_attr"] = left_attr
        datum["right_set"] = right_set
        datum["right_attr"] = right_attr
        datum["subset_id"] = subset_id
        datum["user_auth_string"] = user_auth

        return self.post_then_get(REQ_SCHEMA, REP_SCHEMA, datum, "/joinsetup")


    # -----------------------------------------------------------------------
    # predicate_join -> /predicatejoin

    def predicate_join(self, left_set, right_set, predicate, common_type, result_type, result_set, user_auth=""):
        (REQ_SCHEMA,REP_SCHEMA) = self.get_schemas("predicate_join")

        datum = collections.OrderedDict()
        datum["left_set"] = left_set
        datum["right_set"] = right_set
        datum["common_type"] = common_type
        datum["result_type"] = result_type
        datum["result_set"] = result_set
        datum["user_auth_string"] = user_auth
        datum["predicate"] = predicate

        return self.post_then_get(REQ_SCHEMA, REP_SCHEMA, datum, "/predicatejoin")


    # -----------------------------------------------------------------------
    # register_type_transform -> /registertypetransform

    def register_type_transform(self, type_id, new_type_id, transform_map):
        (REQ_SCHEMA,REP_SCHEMA) = self.get_schemas("register_type_transform")

        datum = collections.OrderedDict()
        datum["type_id"] = type_id
        datum["new_type_id"] = new_type_id
        datum["transform_map"] = transform_map

        return self.post_then_get(REQ_SCHEMA, REP_SCHEMA, datum, "/registertypetransform")

    # ------------- END functions for GPUdb developers -----------------------



    # -----------------------------------------------------------------------
    # Begin autogenerated functions
    # -----------------------------------------------------------------------

    # @begin_autogen 

    def load_gpudb_schemas( self ):
        """Saves all request and response schemas for GPUdb queries
           in a lookup table (lookup by query name).
        """
        self.gpudb_schemas = {}
        name = "gpudb_response"
        RSP_SCHEMA_STR = """{"type":"record","name":"gaia_response","fields":[{"name":"status","type":"string"},{"name":"message","type":"string"},{"name":"data_type","type":"string"},{"name":"data","type":"bytes"},{"name":"data_str","type":"string"}]}"""
        self.gpudb_schemas[ name ] = { "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "trigger_notification"
        RSP_SCHEMA_STR = """{"type":"record","name":"trigger_notification","fields":[{"name":"trigger_id","type":"string"},{"name":"set_id","type":"string"},{"name":"object_id","type":"string"},{"name":"object_data","type":"bytes"}]}"""
        self.gpudb_schemas[ name ] = { "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "admin_shutdown"
        REQ_SCHEMA_STR = """{"type":"record","name":"admin_shutdown_request","fields":[{"name":"exit_type","type":"string"},{"name":"authorization","type":"string"},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"admin_shutdown_response","fields":[{"name":"exit_status","type":"string"}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "aggregate_convex_hull"
        REQ_SCHEMA_STR = """{"type":"record","name":"aggregate_convex_hull_request","fields":[{"name":"table_name","type":"string"},{"name":"x_column_name","type":"string"},{"name":"y_column_name","type":"string"},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"aggregate_convex_hull_response","fields":[{"name":"x_vector","type":{"type":"array","items":"double"}},{"name":"y_vector","type":{"type":"array","items":"double"}},{"name":"count","type":"int"},{"name":"is_valid","type":"boolean"}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "aggregate_group_by"
        REQ_SCHEMA_STR = """{"type":"record","name":"aggregate_group_by_request","fields":[{"name":"table_name","type":"string"},{"name":"column_names","type":{"type":"array","items":"string"}},{"name":"offset","type":"long"},{"name":"limit","type":"long"},{"name":"encoding","type":"string"},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"aggregate_group_by_response","fields":[{"name":"response_schema_str","type":"string"},{"name":"binary_encoded_response","type":"bytes"},{"name":"json_encoded_response","type":"string"}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "aggregate_histogram"
        REQ_SCHEMA_STR = """{"type":"record","name":"aggregate_histogram_request","fields":[{"name":"table_name","type":"string"},{"name":"column_name","type":"string"},{"name":"start","type":"double"},{"name":"end","type":"double"},{"name":"interval","type":"double"},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"aggregate_histogram_response","fields":[{"name":"counts","type":{"type":"array","items":"double"}},{"name":"start","type":"double"},{"name":"end","type":"double"}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "aggregate_k_means"
        REQ_SCHEMA_STR = """{"type":"record","name":"aggregate_k_means_request","fields":[{"name":"table_name","type":"string"},{"name":"column_names","type":{"type":"array","items":"string"}},{"name":"k","type":"int"},{"name":"tolerance","type":"double"},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"aggregate_k_means_response","fields":[{"name":"means","type":{"type":"array","items":{"type":"array","items":"double"}}},{"name":"counts","type":{"type":"array","items":"long"}},{"name":"rms_dists","type":{"type":"array","items":"double"}},{"name":"count","type":"long"},{"name":"rms_dist","type":"double"},{"name":"tolerance","type":"double"},{"name":"num_iters","type":"int"}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "aggregate_min_max"
        REQ_SCHEMA_STR = """{"type":"record","name":"aggregate_min_max_request","fields":[{"name":"table_name","type":"string"},{"name":"column_name","type":"string"},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"aggregate_min_max_response","fields":[{"name":"min","type":"double"},{"name":"max","type":"double"}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "aggregate_statistics"
        REQ_SCHEMA_STR = """{"type":"record","name":"aggregate_statistics_request","fields":[{"name":"table_name","type":"string"},{"name":"column_name","type":"string"},{"name":"stats","type":"string"},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"aggregate_statistics_response","fields":[{"name":"stats","type":{"type":"map","values":"double"}}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "aggregate_statistics_by_range"
        REQ_SCHEMA_STR = """{"type":"record","name":"aggregate_statistics_by_range_request","fields":[{"name":"table_name","type":"string"},{"name":"select_expression","type":"string"},{"name":"column_name","type":"string"},{"name":"value_column_name","type":"string"},{"name":"stats","type":"string"},{"name":"start","type":"double"},{"name":"end","type":"double"},{"name":"interval","type":"double"},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"aggregate_statistics_by_range_response","fields":[{"name":"stats","type":{"type":"map","values":{"type":"array","items":"double"}}}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "aggregate_unique"
        REQ_SCHEMA_STR = """{"type":"record","name":"aggregate_unique_request","fields":[{"name":"table_name","type":"string"},{"name":"column_name","type":"string"},{"name":"offset","type":"long"},{"name":"limit","type":"long"},{"name":"encoding","type":"string"},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"aggregate_unique_response","fields":[{"name":"table_name","type":"string"},{"name":"response_schema_str","type":"string"},{"name":"binary_encoded_response","type":"bytes"},{"name":"json_encoded_response","type":"string"}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "alter_system_properties"
        REQ_SCHEMA_STR = """{"type":"record","name":"alter_system_properties_request","fields":[{"name":"property_updates_map","type":{"type":"map","values":"string"}},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"alter_system_properties_response","fields":[{"name":"updated_properties_map","type":{"type":"map","values":"string"}}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "alter_table"
        REQ_SCHEMA_STR = """{"type":"record","name":"alter_table_request","fields":[{"name":"table_name","type":"string"},{"name":"column_name","type":"string"},{"name":"action","type":"string"},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"alter_table_response","fields":[{"name":"status","type":"string"}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "alter_table_metadata"
        REQ_SCHEMA_STR = """{"type":"record","name":"alter_table_metadata_request","fields":[{"name":"table_names","type":{"type":"array","items":"string"}},{"name":"metadata_map","type":{"type":"map","values":"string"}},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"alter_table_metadata_response","fields":[{"name":"table_names","type":{"type":"array","items":"string"}},{"name":"metadata_map","type":{"type":"map","values":"string"}}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "alter_table_properties"
        REQ_SCHEMA_STR = """{"type":"record","name":"alter_table_properties_request","fields":[{"name":"table_names","type":{"type":"array","items":"string"}},{"name":"properties_map","type":{"type":"map","values":"string"}},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"alter_table_properties_response","fields":[{"name":"table_names","type":{"type":"array","items":"string"}},{"name":"properties_map","type":{"type":"map","values":"string"}}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "clear_table"
        REQ_SCHEMA_STR = """{"type":"record","name":"clear_table_request","fields":[{"name":"table_name","type":"string"},{"name":"authorization","type":"string"},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"clear_table_response","fields":[{"name":"status","type":"string"},{"name":"table_name","type":"string"}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "clear_table_monitor"
        REQ_SCHEMA_STR = """{"type":"record","name":"clear_table_monitor_request","fields":[{"name":"topic_id","type":"string"},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"clear_table_monitor_response","fields":[{"name":"topic_id","type":"string"}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "clear_trigger"
        REQ_SCHEMA_STR = """{"type":"record","name":"clear_trigger_request","fields":[{"name":"trigger_id","type":"string"},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"clear_trigger_response","fields":[{"name":"trigger_id","type":"string"}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "create_join_table"
        REQ_SCHEMA_STR = """{"type":"record","name":"create_join_table_request","fields":[{"name":"join_table_name","type":"string"},{"name":"table_names","type":{"type":"array","items":"string"}},{"name":"aliases","type":{"type":"array","items":"string"}},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"create_join_table_response","fields":[{"name":"join_table_name","type":"string"}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "create_table"
        REQ_SCHEMA_STR = """{"type":"record","name":"create_table_request","fields":[{"name":"table_name","type":"string"},{"name":"type_id","type":"string"},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"create_table_response","fields":[{"name":"table_name","type":"string"},{"name":"type_id","type":"string"},{"name":"is_collection","type":"boolean"}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "create_table_monitor"
        REQ_SCHEMA_STR = """{"type":"record","name":"create_table_monitor_request","fields":[{"name":"table_name","type":"string"},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"create_table_monitor_response","fields":[{"name":"topic_id","type":"string"},{"name":"table_name","type":"string"},{"name":"type_schema","type":"string"}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "create_trigger_by_area"
        REQ_SCHEMA_STR = """{"type":"record","name":"create_trigger_by_area_request","fields":[{"name":"request_id","type":"string"},{"name":"table_names","type":{"type":"array","items":"string"}},{"name":"x_column_name","type":"string"},{"name":"x_vector","type":{"type":"array","items":"double"}},{"name":"y_column_name","type":"string"},{"name":"y_vector","type":{"type":"array","items":"double"}},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"create_trigger_by_area_response","fields":[{"name":"trigger_id","type":"string"}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "create_trigger_by_range"
        REQ_SCHEMA_STR = """{"type":"record","name":"create_trigger_by_range_request","fields":[{"name":"request_id","type":"string"},{"name":"table_names","type":{"type":"array","items":"string"}},{"name":"column_name","type":"string"},{"name":"min","type":"double"},{"name":"max","type":"double"},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"create_trigger_by_range_response","fields":[{"name":"trigger_id","type":"string"}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "create_type"
        REQ_SCHEMA_STR = """{"type":"record","name":"create_type_request","fields":[{"name":"type_definition","type":"string"},{"name":"label","type":"string"},{"name":"properties","type":{"type":"map","values":{"type":"array","items":"string"}}},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"create_type_response","fields":[{"name":"type_id","type":"string"},{"name":"type_definition","type":"string"},{"name":"label","type":"string"},{"name":"properties","type":{"type":"map","values":{"type":"array","items":"string"}}}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "delete_records"
        REQ_SCHEMA_STR = """{"type":"record","name":"delete_records_request","fields":[{"name":"table_name","type":"string"},{"name":"expressions","type":{"type":"array","items":"string"}},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"delete_records_response","fields":[{"name":"count_deleted","type":"long"},{"name":"counts_deleted","type":{"type":"array","items":"long"}}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "filter"
        REQ_SCHEMA_STR = """{"type":"record","name":"filter_request","fields":[{"name":"table_name","type":"string"},{"name":"view_name","type":"string"},{"name":"expression","type":"string"},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"filter_response","fields":[{"name":"count","type":"long"}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "filter_by_area"
        REQ_SCHEMA_STR = """{"type":"record","name":"filter_by_area_request","fields":[{"name":"table_name","type":"string"},{"name":"view_name","type":"string"},{"name":"x_column_name","type":"string"},{"name":"x_vector","type":{"type":"array","items":"double"}},{"name":"y_column_name","type":"string"},{"name":"y_vector","type":{"type":"array","items":"double"}},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"filter_by_area_response","fields":[{"name":"count","type":"long"}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "filter_by_box"
        REQ_SCHEMA_STR = """{"type":"record","name":"filter_by_box_request","fields":[{"name":"table_name","type":"string"},{"name":"view_name","type":"string"},{"name":"x_column_name","type":"string"},{"name":"min_x","type":"double"},{"name":"max_x","type":"double"},{"name":"y_column_name","type":"string"},{"name":"min_y","type":"double"},{"name":"max_y","type":"double"},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"filter_by_box_response","fields":[{"name":"count","type":"long"}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "filter_by_geometry"
        REQ_SCHEMA_STR = """{"type":"record","name":"filter_by_geometry_request","fields":[{"name":"table_name","type":"string"},{"name":"view_name","type":"string"},{"name":"column_name","type":"string"},{"name":"input_wkt","type":"string"},{"name":"operation","type":"string"},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"filter_by_geometry_response","fields":[{"name":"count","type":"long"}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "filter_by_list"
        REQ_SCHEMA_STR = """{"type":"record","name":"filter_by_list_request","fields":[{"name":"table_name","type":"string"},{"name":"view_name","type":"string"},{"name":"column_values_map","type":{"type":"map","values":{"type":"array","items":"string"}}},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"filter_by_list_response","fields":[{"name":"count","type":"long"}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "filter_by_radius"
        REQ_SCHEMA_STR = """{"type":"record","name":"filter_by_radius_request","fields":[{"name":"table_name","type":"string"},{"name":"view_name","type":"string"},{"name":"x_column_name","type":"string"},{"name":"x_center","type":"double"},{"name":"y_column_name","type":"string"},{"name":"y_center","type":"double"},{"name":"radius","type":"double"},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"filter_by_radius_response","fields":[{"name":"count","type":"long"}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "filter_by_range"
        REQ_SCHEMA_STR = """{"type":"record","name":"filter_by_range_request","fields":[{"name":"table_name","type":"string"},{"name":"view_name","type":"string"},{"name":"column_name","type":"string"},{"name":"lower_bound","type":"double"},{"name":"upper_bound","type":"double"},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"filter_by_range_response","fields":[{"name":"count","type":"long"}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "filter_by_series"
        REQ_SCHEMA_STR = """{"type":"record","name":"filter_by_series_request","fields":[{"name":"table_name","type":"string"},{"name":"view_name","type":"string"},{"name":"track_id","type":"string"},{"name":"target_track_ids","type":{"type":"array","items":"string"}},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"filter_by_series_response","fields":[{"name":"count","type":"long"}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "filter_by_string"
        REQ_SCHEMA_STR = """{"type":"record","name":"filter_by_string_request","fields":[{"name":"table_name","type":"string"},{"name":"view_name","type":"string"},{"name":"expression","type":"string"},{"name":"mode","type":"string"},{"name":"column_names","type":{"type":"array","items":"string"}},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"filter_by_string_response","fields":[{"name":"count","type":"long"}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "filter_by_table"
        REQ_SCHEMA_STR = """{"type":"record","name":"filter_by_table_request","fields":[{"name":"table_name","type":"string"},{"name":"view_name","type":"string"},{"name":"column_name","type":"string"},{"name":"source_table_name","type":"string"},{"name":"source_table_column_name","type":"string"},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"filter_by_table_response","fields":[{"name":"count","type":"long"}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "filter_by_value"
        REQ_SCHEMA_STR = """{"type":"record","name":"filter_by_value_request","fields":[{"name":"table_name","type":"string"},{"name":"view_name","type":"string"},{"name":"is_string","type":"boolean"},{"name":"value","type":"double"},{"name":"value_str","type":"string"},{"name":"column_name","type":"string"},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"filter_by_value_response","fields":[{"name":"count","type":"long"}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "get_records"
        REQ_SCHEMA_STR = """{"type":"record","name":"get_records_request","fields":[{"name":"table_name","type":"string"},{"name":"offset","type":"long"},{"name":"limit","type":"long"},{"name":"encoding","type":"string"},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"get_records_response","fields":[{"name":"table_name","type":"string"},{"name":"type_name","type":"string"},{"name":"type_schema","type":"string"},{"name":"records_binary","type":{"type":"array","items":"bytes"}},{"name":"records_json","type":{"type":"array","items":"string"}}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "get_records_by_column"
        REQ_SCHEMA_STR = """{"type":"record","name":"get_records_by_column_request","fields":[{"name":"table_name","type":"string"},{"name":"column_names","type":{"type":"array","items":"string"}},{"name":"offset","type":"long"},{"name":"limit","type":"long"},{"name":"encoding","type":"string"},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"get_records_by_column_response","fields":[{"name":"table_name","type":"string"},{"name":"response_schema_str","type":"string"},{"name":"binary_encoded_response","type":"bytes"},{"name":"json_encoded_response","type":"string"}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "get_records_by_series"
        REQ_SCHEMA_STR = """{"type":"record","name":"get_records_by_series_request","fields":[{"name":"table_name","type":"string"},{"name":"world_table_name","type":"string"},{"name":"offset","type":"int"},{"name":"limit","type":"int"},{"name":"encoding","type":"string"},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"get_records_by_series_response","fields":[{"name":"table_names","type":{"type":"array","items":"string"}},{"name":"type_names","type":{"type":"array","items":"string"}},{"name":"type_schemas","type":{"type":"array","items":"string"}},{"name":"list_records_binary","type":{"type":"array","items":{"type":"array","items":"bytes"}}},{"name":"list_records_json","type":{"type":"array","items":{"type":"array","items":"string"}}}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "get_records_from_collection"
        REQ_SCHEMA_STR = """{"type":"record","name":"get_records_from_collection_request","fields":[{"name":"table_name","type":"string"},{"name":"offset","type":"long"},{"name":"limit","type":"long"},{"name":"encoding","type":"string"},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"get_records_from_collection_response","fields":[{"name":"table_name","type":"string"},{"name":"type_names","type":{"type":"array","items":"string"}},{"name":"records_binary","type":{"type":"array","items":"bytes"}},{"name":"records_json","type":{"type":"array","items":"string"}},{"name":"record_ids","type":{"type":"array","items":"string"}}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "has_table"
        REQ_SCHEMA_STR = """{"type":"record","name":"has_table_request","fields":[{"name":"table_name","type":"string"},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"has_table_response","fields":[{"name":"table_name","type":"string"},{"name":"table_exists","type":"boolean"}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "has_type"
        REQ_SCHEMA_STR = """{"type":"record","name":"has_type_request","fields":[{"name":"type_id","type":"string"},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"has_type_response","fields":[{"name":"type_id","type":"string"},{"name":"type_exists","type":"boolean"}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "insert_records"
        REQ_SCHEMA_STR = """{"type":"record","name":"insert_records_request","fields":[{"name":"table_name","type":"string"},{"name":"list","type":{"type":"array","items":"bytes"}},{"name":"list_str","type":{"type":"array","items":"string"}},{"name":"list_encoding","type":"string"},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"insert_records_response","fields":[{"name":"record_ids","type":{"type":"array","items":"string"}},{"name":"count_inserted","type":"int"},{"name":"count_updated","type":"int"}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "insert_records_random"
        REQ_SCHEMA_STR = """{"type":"record","name":"insert_records_random_request","fields":[{"name":"table_name","type":"string"},{"name":"count","type":"long"},{"name":"options","type":{"type":"map","values":{"type":"map","values":"double"}}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"insert_records_random_response","fields":[{"name":"table_name","type":"string"},{"name":"count","type":"long"}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "insert_symbol"
        REQ_SCHEMA_STR = """{"type":"record","name":"insert_symbol_request","fields":[{"name":"symbol_id","type":"string"},{"name":"symbol_format","type":"string"},{"name":"symbol_data","type":"bytes"},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"insert_symbol_response","fields":[{"name":"symbol_id","type":"string"}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "show_system_properties"
        REQ_SCHEMA_STR = """{"type":"record","name":"show_system_properties_request","fields":[{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"show_system_properties_response","fields":[{"name":"property_map","type":{"type":"map","values":"string"}}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "show_system_status"
        REQ_SCHEMA_STR = """{"type":"record","name":"show_system_status_request","fields":[{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"show_system_status_response","fields":[{"name":"status_map","type":{"type":"map","values":"string"}}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "show_system_timing"
        REQ_SCHEMA_STR = """{"type":"record","name":"show_system_timing_request","fields":[{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"show_system_timing_response","fields":[{"name":"endpoints","type":{"type":"array","items":"string"}},{"name":"time_in_ms","type":{"type":"array","items":"float"}},{"name":"jobIds","type":{"type":"array","items":"string"}}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "show_table"
        REQ_SCHEMA_STR = """{"type":"record","name":"show_table_request","fields":[{"name":"table_name","type":"string"},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"show_table_response","fields":[{"name":"table_name","type":"string"},{"name":"table_names","type":{"type":"array","items":"string"}},{"name":"is_collection","type":{"type":"array","items":"boolean"}},{"name":"is_view","type":{"type":"array","items":"boolean"}},{"name":"type_ids","type":{"type":"array","items":"string"}},{"name":"type_schemas","type":{"type":"array","items":"string"}},{"name":"type_labels","type":{"type":"array","items":"string"}},{"name":"properties","type":{"type":"array","items":{"type":"map","values":{"type":"array","items":"string"}}}},{"name":"ttls","type":{"type":"array","items":"int"}},{"name":"sizes","type":{"type":"array","items":"long"}},{"name":"full_sizes","type":{"type":"array","items":"long"}},{"name":"total_size","type":"long"},{"name":"total_full_size","type":"long"}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "show_table_metadata"
        REQ_SCHEMA_STR = """{"type":"record","name":"show_table_metadata_request","fields":[{"name":"table_names","type":{"type":"array","items":"string"}},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"show_table_metadata_response","fields":[{"name":"table_names","type":{"type":"array","items":"string"}},{"name":"metadata_maps","type":{"type":"array","items":{"type":"map","values":"string"}}}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "show_table_properties"
        REQ_SCHEMA_STR = """{"type":"record","name":"show_table_properties_request","fields":[{"name":"table_names","type":{"type":"array","items":"string"}},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"show_table_properties_response","fields":[{"name":"table_names","type":{"type":"array","items":"string"}},{"name":"properties_maps","type":{"type":"array","items":{"type":"map","values":"string"}}}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "show_tables_by_type"
        REQ_SCHEMA_STR = """{"type":"record","name":"show_tables_by_type_request","fields":[{"name":"type_id","type":"string"},{"name":"label","type":"string"},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"show_tables_by_type_response","fields":[{"name":"table_names","type":{"type":"array","items":"string"}}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "show_triggers"
        REQ_SCHEMA_STR = """{"type":"record","name":"show_triggers_request","fields":[{"name":"trigger_ids","type":{"type":"array","items":"string"}},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"show_triggers_response","fields":[{"name":"trigger_map","type":{"type":"map","values":{"type":"map","values":"string"}}}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "show_types"
        REQ_SCHEMA_STR = """{"type":"record","name":"show_types_request","fields":[{"name":"type_id","type":"string"},{"name":"label","type":"string"},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"show_types_response","fields":[{"name":"type_ids","type":{"type":"array","items":"string"}},{"name":"type_schemas","type":{"type":"array","items":"string"}},{"name":"labels","type":{"type":"array","items":"string"}},{"name":"properties","type":{"type":"array","items":{"type":"map","values":{"type":"array","items":"string"}}}}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "update_records"
        REQ_SCHEMA_STR = """{"type":"record","name":"update_records_request","fields":[{"name":"table_name","type":"string"},{"name":"expressions","type":{"type":"array","items":"string"}},{"name":"new_values_maps","type":{"type":"array","items":{"type":"map","values":"string"}}},{"name":"records_to_insert","type":{"type":"array","items":"bytes"}},{"name":"records_to_insert_str","type":{"type":"array","items":"string"}},{"name":"record_encoding","type":"string"},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"update_records_response","fields":[{"name":"count_updated","type":"long"},{"name":"counts_updated","type":{"type":"array","items":"long"}},{"name":"count_inserted","type":"long"},{"name":"counts_inserted","type":{"type":"array","items":"long"}}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "update_records_by_series"
        REQ_SCHEMA_STR = """{"type":"record","name":"update_records_by_series_request","fields":[{"name":"table_name","type":"string"},{"name":"world_table_name","type":"string"},{"name":"view_name","type":"string"},{"name":"reserved","type":{"type":"array","items":"string"}},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"update_records_by_series_response","fields":[{"name":"count","type":"int"}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "visualize_image"
        REQ_SCHEMA_STR = """{"type":"record","name":"visualize_image_request","fields":[{"name":"table_names","type":{"type":"array","items":"string"}},{"name":"world_table_names","type":{"type":"array","items":"string"}},{"name":"x_column_name","type":"string"},{"name":"y_column_name","type":"string"},{"name":"track_ids","type":{"type":"array","items":{"type":"array","items":"string"}}},{"name":"min_x","type":"double"},{"name":"max_x","type":"double"},{"name":"min_y","type":"double"},{"name":"max_y","type":"double"},{"name":"width","type":"int"},{"name":"height","type":"int"},{"name":"projection","type":"string"},{"name":"bg_color","type":"long"},{"name":"do_points","type":{"type":"array","items":"boolean"}},{"name":"do_shapes","type":{"type":"array","items":"boolean"}},{"name":"do_tracks","type":{"type":"array","items":"boolean"}},{"name":"do_symbology","type":{"type":"array","items":"boolean"}},{"name":"pointcolors","type":{"type":"array","items":"long"}},{"name":"pointsizes","type":{"type":"array","items":"int"}},{"name":"pointshapes","type":{"type":"array","items":"string"}},{"name":"shapelinewidths","type":{"type":"array","items":"int"}},{"name":"shapelinecolors","type":{"type":"array","items":"long"}},{"name":"shapefillcolors","type":{"type":"array","items":"long"}},{"name":"tracklinewidths","type":{"type":"array","items":"int"}},{"name":"tracklinecolors","type":{"type":"array","items":"long"}},{"name":"trackmarkersizes","type":{"type":"array","items":"int"}},{"name":"trackmarkercolors","type":{"type":"array","items":"long"}},{"name":"trackmarkershapes","type":{"type":"array","items":"string"}},{"name":"trackheadcolors","type":{"type":"array","items":"long"}},{"name":"trackheadsizes","type":{"type":"array","items":"int"}},{"name":"trackheadshapes","type":{"type":"array","items":"string"}},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"visualize_image_response","fields":[{"name":"width","type":"double"},{"name":"height","type":"double"},{"name":"bg_color","type":"long"},{"name":"image_data","type":"bytes"}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "visualize_image_classbreak"
        REQ_SCHEMA_STR = """{"type":"record","name":"visualize_image_classbreak_request","fields":[{"name":"table_names","type":{"type":"array","items":"string"}},{"name":"world_table_names","type":{"type":"array","items":"string"}},{"name":"x_column_name","type":"string"},{"name":"y_column_name","type":"string"},{"name":"track_ids","type":{"type":"array","items":{"type":"array","items":"string"}}},{"name":"cb_column_name1","type":"string"},{"name":"cb_vals1","type":{"type":"array","items":"string"}},{"name":"cb_column_name2","type":{"type":"array","items":"string"}},{"name":"cb_vals2","type":{"type":"array","items":{"type":"array","items":"string"}}},{"name":"min_x","type":"double"},{"name":"max_x","type":"double"},{"name":"min_y","type":"double"},{"name":"max_y","type":"double"},{"name":"width","type":"int"},{"name":"height","type":"int"},{"name":"projection","type":"string"},{"name":"bg_color","type":"long"},{"name":"do_points","type":{"type":"array","items":"boolean"}},{"name":"do_shapes","type":{"type":"array","items":"boolean"}},{"name":"do_tracks","type":{"type":"array","items":"boolean"}},{"name":"do_symbology","type":{"type":"array","items":"boolean"}},{"name":"pointcolors","type":{"type":"array","items":"long"}},{"name":"pointsizes","type":{"type":"array","items":"int"}},{"name":"pointshapes","type":{"type":"array","items":"string"}},{"name":"shapelinewidths","type":{"type":"array","items":"int"}},{"name":"shapelinecolors","type":{"type":"array","items":"long"}},{"name":"shapefillcolors","type":{"type":"array","items":"long"}},{"name":"tracklinewidths","type":{"type":"array","items":"int"}},{"name":"tracklinecolors","type":{"type":"array","items":"long"}},{"name":"trackmarkersizes","type":{"type":"array","items":"int"}},{"name":"trackmarkercolors","type":{"type":"array","items":"long"}},{"name":"trackmarkershapes","type":{"type":"array","items":"string"}},{"name":"trackheadcolors","type":{"type":"array","items":"long"}},{"name":"trackheadsizes","type":{"type":"array","items":"int"}},{"name":"trackheadshapes","type":{"type":"array","items":"string"}},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"visualize_image_classbreak_response","fields":[{"name":"width","type":"double"},{"name":"height","type":"double"},{"name":"bg_color","type":"long"},{"name":"image_data","type":"bytes"}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "visualize_image_heatmap"
        REQ_SCHEMA_STR = """{"type":"record","name":"visualize_image_heatmap_request","fields":[{"name":"table_names","type":{"type":"array","items":"string"}},{"name":"x_column_name","type":"string"},{"name":"y_column_name","type":"string"},{"name":"value_column_name","type":"string"},{"name":"min_x","type":"double"},{"name":"max_x","type":"double"},{"name":"min_y","type":"double"},{"name":"max_y","type":"double"},{"name":"width","type":"int"},{"name":"height","type":"int"},{"name":"projection","type":"string"},{"name":"colormap","type":"string"},{"name":"blur_radius","type":"int"},{"name":"bg_color","type":"long"},{"name":"gradient_start_color","type":"long"},{"name":"gradient_end_color","type":"long"},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"visualize_image_heatmap_response","fields":[{"name":"width","type":"int"},{"name":"height","type":"int"},{"name":"bg_color","type":"long"},{"name":"image_data","type":"bytes"}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "visualize_image_heatmap_classbreak"
        REQ_SCHEMA_STR = """{"type":"record","name":"visualize_image_heatmap_classbreak_request","fields":[{"name":"table_names","type":{"type":"array","items":"string"}},{"name":"x_column_name","type":"string"},{"name":"y_column_name","type":"string"},{"name":"cb_column_name","type":"string"},{"name":"cb_vals","type":{"type":"array","items":"string"}},{"name":"cb_ranges","type":{"type":"array","items":"string"}},{"name":"min_x","type":"double"},{"name":"max_x","type":"double"},{"name":"min_y","type":"double"},{"name":"max_y","type":"double"},{"name":"width","type":"int"},{"name":"height","type":"int"},{"name":"projection","type":"string"},{"name":"colormaps","type":{"type":"array","items":"string"}},{"name":"blur_radii","type":{"type":"array","items":"int"}},{"name":"bg_color","type":"long"},{"name":"gradient_start_colors","type":{"type":"array","items":"long"}},{"name":"gradient_end_colors","type":{"type":"array","items":"long"}},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"visualize_image_heatmap_classbreak_response","fields":[{"name":"width","type":"int"},{"name":"height","type":"int"},{"name":"bg_color","type":"long"},{"name":"image_data","type":"bytes"}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "visualize_image_labels"
        REQ_SCHEMA_STR = """{"type":"record","name":"visualize_image_labels_request","fields":[{"name":"table_name","type":"string"},{"name":"x_column_name","type":"string"},{"name":"y_column_name","type":"string"},{"name":"x_offset","type":"string"},{"name":"y_offset","type":"string"},{"name":"text_string","type":"string"},{"name":"font","type":"string"},{"name":"text_color","type":"string"},{"name":"text_angle","type":"string"},{"name":"text_scale","type":"string"},{"name":"draw_box","type":"string"},{"name":"draw_leader","type":"string"},{"name":"line_width","type":"string"},{"name":"line_color","type":"string"},{"name":"fill_color","type":"string"},{"name":"leader_x_column_name","type":"string"},{"name":"leader_y_column_name","type":"string"},{"name":"min_x","type":"double"},{"name":"max_x","type":"double"},{"name":"min_y","type":"double"},{"name":"max_y","type":"double"},{"name":"width","type":"int"},{"name":"height","type":"int"},{"name":"projection","type":"string"},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"visualize_image_labels_response","fields":[{"name":"width","type":"double"},{"name":"height","type":"double"},{"name":"bg_color","type":"long"},{"name":"image_data","type":"bytes"}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "visualize_video"
        REQ_SCHEMA_STR = """{"type":"record","name":"visualize_video_request","fields":[{"name":"table_names","type":{"type":"array","items":"string"}},{"name":"world_table_names","type":{"type":"array","items":"string"}},{"name":"track_ids","type":{"type":"array","items":{"type":"array","items":"string"}}},{"name":"x_column_name","type":"string"},{"name":"y_column_name","type":"string"},{"name":"min_x","type":"double"},{"name":"max_x","type":"double"},{"name":"min_y","type":"double"},{"name":"max_y","type":"double"},{"name":"width","type":"int"},{"name":"height","type":"int"},{"name":"projection","type":"string"},{"name":"bg_color","type":"long"},{"name":"do_points","type":{"type":"array","items":"boolean"}},{"name":"do_shapes","type":{"type":"array","items":"boolean"}},{"name":"do_tracks","type":{"type":"array","items":"boolean"}},{"name":"pointcolors","type":{"type":"array","items":"long"}},{"name":"pointsizes","type":{"type":"array","items":"int"}},{"name":"pointshapes","type":{"type":"array","items":"string"}},{"name":"shapelinewidths","type":{"type":"array","items":"int"}},{"name":"shapelinecolors","type":{"type":"array","items":"long"}},{"name":"shapefillcolors","type":{"type":"array","items":"long"}},{"name":"tracklinewidths","type":{"type":"array","items":"int"}},{"name":"tracklinecolors","type":{"type":"array","items":"long"}},{"name":"trackmarkersizes","type":{"type":"array","items":"int"}},{"name":"trackmarkercolors","type":{"type":"array","items":"long"}},{"name":"trackmarkershapes","type":{"type":"array","items":"string"}},{"name":"trackheadcolors","type":{"type":"array","items":"long"}},{"name":"trackheadsizes","type":{"type":"array","items":"int"}},{"name":"trackheadshapes","type":{"type":"array","items":"string"}},{"name":"time_intervals","type":{"type":"array","items":{"type":"array","items":"double"}}},{"name":"video_style","type":"string"},{"name":"session_key","type":"string"},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"visualize_video_response","fields":[{"name":"width","type":"double"},{"name":"height","type":"double"},{"name":"bg_color","type":"long"},{"name":"num_frames","type":"int"},{"name":"session_key","type":"string"},{"name":"data","type":{"type":"array","items":"bytes"}}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
        name = "visualize_video_heatmap"
        REQ_SCHEMA_STR = """{"type":"record","name":"visualize_video_heatmap_request","fields":[{"name":"table_names","type":{"type":"array","items":"string"}},{"name":"x_column_name","type":"string"},{"name":"y_column_name","type":"string"},{"name":"min_x","type":"double"},{"name":"max_x","type":"double"},{"name":"min_y","type":"double"},{"name":"max_y","type":"double"},{"name":"time_intervals","type":{"type":"array","items":{"type":"array","items":"double"}}},{"name":"width","type":"int"},{"name":"height","type":"int"},{"name":"projection","type":"string"},{"name":"bg_color","type":"long"},{"name":"colormap","type":"string"},{"name":"blur_radius","type":"int"},{"name":"gradient_start_color","type":"long"},{"name":"gradient_end_color","type":"long"},{"name":"video_style","type":"string"},{"name":"session_key","type":"string"},{"name":"options","type":{"type":"map","values":"string"}}]}"""
        RSP_SCHEMA_STR = """{"type":"record","name":"visualize_video_heatmap_response","fields":[{"name":"width","type":"double"},{"name":"height","type":"double"},{"name":"bg_color","type":"long"},{"name":"num_frames","type":"int"},{"name":"session_key","type":"string"},{"name":"data","type":{"type":"array","items":"bytes"}}]}"""
        self.gpudb_schemas[ name ] = { "REQ_SCHEMA_STR" : REQ_SCHEMA_STR,
                                       "RSP_SCHEMA_STR" : RSP_SCHEMA_STR,
                                       "REQ_SCHEMA" : schema.parse( REQ_SCHEMA_STR ),
                                       "RSP_SCHEMA" : schema.parse( RSP_SCHEMA_STR ) }
    # end load_gpudb_schemas

    # begin admin_shutdown
    def admin_shutdown( self, exit_type = None, authorization = None, options = {}
                        ):
        """Exits the GPUdb server application. A authorization code is required (chosen
        at the time of GPUdb configuration) to successfully complete this
        request."""

        assert isinstance( exit_type, (str, unicode)), "admin_shutdown(): Argument 'exit_type' must be (one) of type(s) '(str, unicode)'; given %s" % type( exit_type ).__name__
        assert isinstance( authorization, (str, unicode)), "admin_shutdown(): Argument 'authorization' must be (one) of type(s) '(str, unicode)'; given %s" % type( authorization ).__name__
        assert isinstance( options, (dict)), "admin_shutdown(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "admin_shutdown" )

        obj = collections.OrderedDict()
        obj['exit_type'] = exit_type
        obj['authorization'] = authorization
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/admin/shutdown' )
    # end admin_shutdown


    # begin aggregate_convex_hull
    def aggregate_convex_hull( self, table_name = None, x_column_name = None,
                               y_column_name = None, options = {} ):
        """Calculates and returns the convex hull for the values in a table specified by
        input parameter *table_name*."""

        assert isinstance( table_name, (str, unicode)), "aggregate_convex_hull(): Argument 'table_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( table_name ).__name__
        assert isinstance( x_column_name, (str, unicode)), "aggregate_convex_hull(): Argument 'x_column_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( x_column_name ).__name__
        assert isinstance( y_column_name, (str, unicode)), "aggregate_convex_hull(): Argument 'y_column_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( y_column_name ).__name__
        assert isinstance( options, (dict)), "aggregate_convex_hull(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "aggregate_convex_hull" )

        obj = collections.OrderedDict()
        obj['table_name'] = table_name
        obj['x_column_name'] = x_column_name
        obj['y_column_name'] = y_column_name
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/aggregate/convexhull' )
    # end aggregate_convex_hull


    # begin aggregate_group_by
    def aggregate_group_by( self, table_name = None, column_names = None, offset =
                            None, limit = 1000, encoding = 'binary', options =
                            {} ):
        """Calculates unique combinations (i.e. groups) of values for the given columns
        in a given table/view/collection and computes aggregates on each unique
        combination. This is somewhat analogous to an SQL-style SELECT...GROUP
        BY. Any column(s) can be grouped on, but only non-string (i.e. numeric)
        columns may be used for computing aggregates.  The results can be paged
        via the input parameter *offset* and input parameter *limit* parameters.
        For example, to get 10 groups with the largest counts the inputs would
        be: limit=10, options={"sort_order":"descending", "sort_by":"value"}.
        Input parameter *options* can be used to customize behavior of this call
        e.g. filtering or sorting the results.   To group by 'x' and 'y' and
        compute the number of objects within each group, use
        column_names=['x','y','count(*)'].  To also compute the sum of 'z' over
        each group, use column_names=['x','y','count(*)','sum(z)'].  Available
        aggregation functions are: 'count(*)', 'sum', 'min', 'max', 'avg',
        'mean', 'stddev', 'stddev_pop', 'stddev_samp', 'var', 'var_pop' and
        'var_samp'.  The response is returned as a dynamic schema. For details
        see: {dynamic schemas documentation}@{link ../../concepts/index.html
        #dynamic-schemas}."""

        assert isinstance( table_name, (str, unicode)), "aggregate_group_by(): Argument 'table_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( table_name ).__name__
        assert isinstance( column_names, (list)), "aggregate_group_by(): Argument 'column_names' must be (one) of type(s) '(list)'; given %s" % type( column_names ).__name__
        assert isinstance( offset, (int, long, float)), "aggregate_group_by(): Argument 'offset' must be (one) of type(s) '(int, long, float)'; given %s" % type( offset ).__name__
        assert isinstance( limit, (int, long, float)), "aggregate_group_by(): Argument 'limit' must be (one) of type(s) '(int, long, float)'; given %s" % type( limit ).__name__
        assert isinstance( encoding, (str, unicode)), "aggregate_group_by(): Argument 'encoding' must be (one) of type(s) '(str, unicode)'; given %s" % type( encoding ).__name__
        assert isinstance( options, (dict)), "aggregate_group_by(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "aggregate_group_by" )

        obj = collections.OrderedDict()
        obj['table_name'] = table_name
        obj['column_names'] = column_names
        obj['offset'] = offset
        obj['limit'] = limit
        obj['encoding'] = encoding
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/aggregate/groupby' )
    # end aggregate_group_by


    # begin aggregate_histogram
    def aggregate_histogram( self, table_name = None, column_name = None, start =
                             None, end = None, interval = None, options = {} ):
        """Performs a histogram calculation given a table, a column, and an interval
        function. The input parameter *interval* is used to produce bins of that
        size and the result, computed over the records falling within each bin,
        is returned.  For each bin, the start value is inclusive, but the end
        value is exclusive--except for the very last bin for which the end value
        is also inclusive.  The value returned for each bin is the number of
        records in it, except when a column name is provided as a *value_column*
        in input parameter *options*.  In this latter case the sum of the values
        corresponding to the *value_column* is used as the result instead."""

        assert isinstance( table_name, (str, unicode)), "aggregate_histogram(): Argument 'table_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( table_name ).__name__
        assert isinstance( column_name, (str, unicode)), "aggregate_histogram(): Argument 'column_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( column_name ).__name__
        assert isinstance( start, (int, long, float)), "aggregate_histogram(): Argument 'start' must be (one) of type(s) '(int, long, float)'; given %s" % type( start ).__name__
        assert isinstance( end, (int, long, float)), "aggregate_histogram(): Argument 'end' must be (one) of type(s) '(int, long, float)'; given %s" % type( end ).__name__
        assert isinstance( interval, (int, long, float)), "aggregate_histogram(): Argument 'interval' must be (one) of type(s) '(int, long, float)'; given %s" % type( interval ).__name__
        assert isinstance( options, (dict)), "aggregate_histogram(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "aggregate_histogram" )

        obj = collections.OrderedDict()
        obj['table_name'] = table_name
        obj['column_name'] = column_name
        obj['start'] = start
        obj['end'] = end
        obj['interval'] = interval
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/aggregate/histogram' )
    # end aggregate_histogram


    # begin aggregate_k_means
    def aggregate_k_means( self, table_name = None, column_names = None, k = None,
                           tolerance = None, options = {} ):
        """This endpoint runs the k-means algorithm - a heuristic algorithm that
        attempts to do k-means clustering.  An ideal k-means clustering
        algorithm selects k points such that the sum of the mean squared
        distances of each member of the set to the nearest of the k points is
        minimized.  The k-means algorithm however does not necessarily produce
        such an ideal cluster.   It begins with a randomly selected set of k
        points and then refines the location of the points iteratively and
        settles to a local minimum.  Various parameters and options are provided
        to control the heuristic search."""

        assert isinstance( table_name, (str, unicode)), "aggregate_k_means(): Argument 'table_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( table_name ).__name__
        assert isinstance( column_names, (list)), "aggregate_k_means(): Argument 'column_names' must be (one) of type(s) '(list)'; given %s" % type( column_names ).__name__
        assert isinstance( k, (int, long, float)), "aggregate_k_means(): Argument 'k' must be (one) of type(s) '(int, long, float)'; given %s" % type( k ).__name__
        assert isinstance( tolerance, (int, long, float)), "aggregate_k_means(): Argument 'tolerance' must be (one) of type(s) '(int, long, float)'; given %s" % type( tolerance ).__name__
        assert isinstance( options, (dict)), "aggregate_k_means(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "aggregate_k_means" )

        obj = collections.OrderedDict()
        obj['table_name'] = table_name
        obj['column_names'] = column_names
        obj['k'] = k
        obj['tolerance'] = tolerance
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/aggregate/kmeans' )
    # end aggregate_k_means


    # begin aggregate_min_max
    def aggregate_min_max( self, table_name = None, column_name = None, options = {}
                           ):
        """Calculates and returns the minimum and maximum values of a particular column
        in a table."""

        assert isinstance( table_name, (str, unicode)), "aggregate_min_max(): Argument 'table_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( table_name ).__name__
        assert isinstance( column_name, (str, unicode)), "aggregate_min_max(): Argument 'column_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( column_name ).__name__
        assert isinstance( options, (dict)), "aggregate_min_max(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "aggregate_min_max" )

        obj = collections.OrderedDict()
        obj['table_name'] = table_name
        obj['column_name'] = column_name
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/aggregate/minmax' )
    # end aggregate_min_max


    # begin aggregate_statistics
    def aggregate_statistics( self, table_name = None, column_name = None, stats =
                              None, options = {} ):
        """Calculates the requested statistics of a given column in a given table. The
        available statistics are count (number of total objects), mean, stdv
        (standard deviation), variance, skew, kurtosis, sum, min, max,
        weighted_average, cardinality (unique count) and estimated cardinality.
        Estimated cardinality is calculated by using the hyperloglog
        approximation technique. The weighted average statistic requires a
        weight_attribute to be specified in input parameter *options*. The
        weighted average is then defined as the sum of the products of input
        parameter *column_name* times the weight attribute divided by the sum of
        the weight attribute. The response includes a list of the statistics
        requested along with the count of the number of items in the given
        set."""

        assert isinstance( table_name, (str, unicode)), "aggregate_statistics(): Argument 'table_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( table_name ).__name__
        assert isinstance( column_name, (str, unicode)), "aggregate_statistics(): Argument 'column_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( column_name ).__name__
        assert isinstance( stats, (str, unicode)), "aggregate_statistics(): Argument 'stats' must be (one) of type(s) '(str, unicode)'; given %s" % type( stats ).__name__
        assert isinstance( options, (dict)), "aggregate_statistics(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "aggregate_statistics" )

        obj = collections.OrderedDict()
        obj['table_name'] = table_name
        obj['column_name'] = column_name
        obj['stats'] = stats
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/aggregate/statistics' )
    # end aggregate_statistics


    # begin aggregate_statistics_by_range
    def aggregate_statistics_by_range( self, table_name = None, select_expression =
                                       '', column_name = None, value_column_name
                                       = None, stats = None, start = None, end =
                                       None, interval = None, options = {} ):
        """Divides the given set into bins and calculates statistics of the values of a
        value-column in each bin.  The bins are based on the values of a given
        binning-column.  The statistics that may be requested are mean, stdv
        (standard deviation), variance, skew, kurtosis, sum, min, max, first,
        last and weighted average. In addition to the requested statistics the
        count of total samples in each bin is returned. This counts vector is
        just the histogram of the column used to divide the set members into
        bins. The weighted average statistic requires a weight_column to be
        specified in input parameter *options*. The weighted average is then
        defined as the sum of the products of the value column times the weight
        column divided by the sum of the weight column.  There are two methods
        for binning the set members. In the first, which can be used for numeric
        valued binning-columns, a min, max and interval are specified. The
        number of bins, nbins, is the integer upper bound of (max-min)/interval.
        Values that fall in the range [min+n\*interval,min+(n+1)\*interval) are
        placed in the nth bin where n ranges from 0..nbin-2. The final bin is
        [min+(nbin-1)\*interval,max]. In the second method, input parameter
        *options* bin_values specifies a list of binning column values. Binning-
        columns whose value matches the nth member of the bin_values list are
        placed in the nth bin. When a list is provided the binning-column must
        be of type string or int."""

        assert isinstance( table_name, (str, unicode)), "aggregate_statistics_by_range(): Argument 'table_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( table_name ).__name__
        assert isinstance( select_expression, (str, unicode)), "aggregate_statistics_by_range(): Argument 'select_expression' must be (one) of type(s) '(str, unicode)'; given %s" % type( select_expression ).__name__
        assert isinstance( column_name, (str, unicode)), "aggregate_statistics_by_range(): Argument 'column_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( column_name ).__name__
        assert isinstance( value_column_name, (str, unicode)), "aggregate_statistics_by_range(): Argument 'value_column_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( value_column_name ).__name__
        assert isinstance( stats, (str, unicode)), "aggregate_statistics_by_range(): Argument 'stats' must be (one) of type(s) '(str, unicode)'; given %s" % type( stats ).__name__
        assert isinstance( start, (int, long, float)), "aggregate_statistics_by_range(): Argument 'start' must be (one) of type(s) '(int, long, float)'; given %s" % type( start ).__name__
        assert isinstance( end, (int, long, float)), "aggregate_statistics_by_range(): Argument 'end' must be (one) of type(s) '(int, long, float)'; given %s" % type( end ).__name__
        assert isinstance( interval, (int, long, float)), "aggregate_statistics_by_range(): Argument 'interval' must be (one) of type(s) '(int, long, float)'; given %s" % type( interval ).__name__
        assert isinstance( options, (dict)), "aggregate_statistics_by_range(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "aggregate_statistics_by_range" )

        obj = collections.OrderedDict()
        obj['table_name'] = table_name
        obj['select_expression'] = select_expression
        obj['column_name'] = column_name
        obj['value_column_name'] = value_column_name
        obj['stats'] = stats
        obj['start'] = start
        obj['end'] = end
        obj['interval'] = interval
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/aggregate/statistics/byrange' )
    # end aggregate_statistics_by_range


    # begin aggregate_unique
    def aggregate_unique( self, table_name = None, column_name = None, offset =
                          None, limit = 10000, encoding = 'binary', options = {}
                          ):
        """Returns all the unique values from a particular column (specified by input
        parameter *column_name*) of a particular table (specified by input
        parameter *table_name*). If input parameter *column_name* is a numeric
        column the values will be in output parameter *binary_encoded_response*.
        Otherwise if input parameter *column_name* is a string column the values
        will be in output parameter *json_encoded_response*.  input parameter
        *offset* and input parameter *limit* are used to page through the
        results if there are large numbers of unique values. To get the first 10
        unique values sorted in descending order input parameter *options* would
        be::   {"limit":"10","sort_order":"descending"}.  The response is
        returned as a dynamic schema. For details see: {dynamic schemas
        documentation}@{link ../../concepts/index.html#dynamic-schemas}."""

        assert isinstance( table_name, (str, unicode)), "aggregate_unique(): Argument 'table_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( table_name ).__name__
        assert isinstance( column_name, (str, unicode)), "aggregate_unique(): Argument 'column_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( column_name ).__name__
        assert isinstance( offset, (int, long, float)), "aggregate_unique(): Argument 'offset' must be (one) of type(s) '(int, long, float)'; given %s" % type( offset ).__name__
        assert isinstance( limit, (int, long, float)), "aggregate_unique(): Argument 'limit' must be (one) of type(s) '(int, long, float)'; given %s" % type( limit ).__name__
        assert isinstance( encoding, (str, unicode)), "aggregate_unique(): Argument 'encoding' must be (one) of type(s) '(str, unicode)'; given %s" % type( encoding ).__name__
        assert isinstance( options, (dict)), "aggregate_unique(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "aggregate_unique" )

        obj = collections.OrderedDict()
        obj['table_name'] = table_name
        obj['column_name'] = column_name
        obj['offset'] = offset
        obj['limit'] = limit
        obj['encoding'] = encoding
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/aggregate/unique' )
    # end aggregate_unique


    # begin alter_system_properties
    def alter_system_properties( self, property_updates_map = None, options = {} ):
        """The alter_system_properties endpoint is primarily used to simplify the
        testing of gpudb and is not expected to be used during normal execution.
        Commands are given through the properties_update_map whose keys are
        commands and values are strings representing integer values (for example
        '8000') or boolean values ('true' or 'false')."""

        assert isinstance( property_updates_map, (dict)), "alter_system_properties(): Argument 'property_updates_map' must be (one) of type(s) '(dict)'; given %s" % type( property_updates_map ).__name__
        assert isinstance( options, (dict)), "alter_system_properties(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "alter_system_properties" )

        obj = collections.OrderedDict()
        obj['property_updates_map'] = property_updates_map
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/alter/system/properties' )
    # end alter_system_properties


    # begin alter_table
    def alter_table( self, table_name = None, column_name = None, action = None,
                     options = {} ):
        """Creates or deletes an index on a particular column in a given table. Creating
        an index can speed up certain search queries (such as :ref:`get_records
        <get_records_python>`, :ref:`delete_records <delete_records_python>`,
        :ref:`update_records <update_records_python>`) when using expressions
        containing equality or relational operators on indexed columns."""

        assert isinstance( table_name, (str, unicode)), "alter_table(): Argument 'table_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( table_name ).__name__
        assert isinstance( column_name, (str, unicode)), "alter_table(): Argument 'column_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( column_name ).__name__
        assert isinstance( action, (str, unicode)), "alter_table(): Argument 'action' must be (one) of type(s) '(str, unicode)'; given %s" % type( action ).__name__
        assert isinstance( options, (dict)), "alter_table(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "alter_table" )

        obj = collections.OrderedDict()
        obj['table_name'] = table_name
        obj['column_name'] = column_name
        obj['action'] = action
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/alter/table' )
    # end alter_table


    # begin alter_table_metadata
    def alter_table_metadata( self, table_names = None, metadata_map = None, options
                              = {} ):
        """Updates (adds or changes) metadata for tables. The metadata key and values
        must both be strings. This is an easy way to annotate whole tables
        rather than single records within tables.  Some examples of metadata are
        owner of the table, table creation timestamp etc."""

        assert isinstance( table_names, (list)), "alter_table_metadata(): Argument 'table_names' must be (one) of type(s) '(list)'; given %s" % type( table_names ).__name__
        assert isinstance( metadata_map, (dict)), "alter_table_metadata(): Argument 'metadata_map' must be (one) of type(s) '(dict)'; given %s" % type( metadata_map ).__name__
        assert isinstance( options, (dict)), "alter_table_metadata(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "alter_table_metadata" )

        obj = collections.OrderedDict()
        obj['table_names'] = table_names
        obj['metadata_map'] = metadata_map
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/alter/table/metadata' )
    # end alter_table_metadata


    # begin alter_table_properties
    def alter_table_properties( self, table_names = None, properties_map = {},
                                options = {} ):
        """Updates properties for a group of specified tables. The user can change the
        protected-ness of the tables and allow or disallow duplicate child
        tables if they are all collections."""

        assert isinstance( table_names, (list)), "alter_table_properties(): Argument 'table_names' must be (one) of type(s) '(list)'; given %s" % type( table_names ).__name__
        assert isinstance( properties_map, (dict)), "alter_table_properties(): Argument 'properties_map' must be (one) of type(s) '(dict)'; given %s" % type( properties_map ).__name__
        assert isinstance( options, (dict)), "alter_table_properties(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "alter_table_properties" )

        obj = collections.OrderedDict()
        obj['table_names'] = table_names
        obj['properties_map'] = properties_map
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/alter/table/properties' )
    # end alter_table_properties


    # begin clear_table
    def clear_table( self, table_name = '', authorization = '', options = {} ):
        """Clears (drops) one or all tables in the GPUdb cluster. The operation is
        synchronous meaning that the table will be cleared before the function
        returns. The response payload returns the status of the operation along
        with the name of the table that was cleared. For protected tables, this
        function requires an administrator password without which the operation
        will fail."""

        assert isinstance( table_name, (str, unicode)), "clear_table(): Argument 'table_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( table_name ).__name__
        assert isinstance( authorization, (str, unicode)), "clear_table(): Argument 'authorization' must be (one) of type(s) '(str, unicode)'; given %s" % type( authorization ).__name__
        assert isinstance( options, (dict)), "clear_table(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "clear_table" )

        obj = collections.OrderedDict()
        obj['table_name'] = table_name
        obj['authorization'] = authorization
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/clear/table' )
    # end clear_table


    # begin clear_table_monitor
    def clear_table_monitor( self, topic_id = None, options = {} ):
        """Deactivates a table monitor previously created with
        :ref:`create_table_monitor <create_tablemonitor_python>`."""

        assert isinstance( topic_id, (str, unicode)), "clear_table_monitor(): Argument 'topic_id' must be (one) of type(s) '(str, unicode)'; given %s" % type( topic_id ).__name__
        assert isinstance( options, (dict)), "clear_table_monitor(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "clear_table_monitor" )

        obj = collections.OrderedDict()
        obj['topic_id'] = topic_id
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/clear/tablemonitor' )
    # end clear_table_monitor


    # begin clear_trigger
    def clear_trigger( self, trigger_id = None, options = {} ):
        """Clears or cancels the trigger identified by the specified handle. The output
        returns the handle of the trigger cleared as well as indicating success
        or failure of the trigger deactivation."""

        assert isinstance( trigger_id, (str, unicode)), "clear_trigger(): Argument 'trigger_id' must be (one) of type(s) '(str, unicode)'; given %s" % type( trigger_id ).__name__
        assert isinstance( options, (dict)), "clear_trigger(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "clear_trigger" )

        obj = collections.OrderedDict()
        obj['trigger_id'] = trigger_id
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/clear/trigger' )
    # end clear_trigger


    # begin create_join_table
    def create_join_table( self, join_table_name = None, table_names = None, aliases
                           = None, options = {} ):
        """Creates a joint_table which is a list of tables and aliases for those
        tables."""

        assert isinstance( join_table_name, (str, unicode)), "create_join_table(): Argument 'join_table_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( join_table_name ).__name__
        assert isinstance( table_names, (list)), "create_join_table(): Argument 'table_names' must be (one) of type(s) '(list)'; given %s" % type( table_names ).__name__
        assert isinstance( aliases, (list)), "create_join_table(): Argument 'aliases' must be (one) of type(s) '(list)'; given %s" % type( aliases ).__name__
        assert isinstance( options, (dict)), "create_join_table(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "create_join_table" )

        obj = collections.OrderedDict()
        obj['join_table_name'] = join_table_name
        obj['table_names'] = table_names
        obj['aliases'] = aliases
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/create/jointable' )
    # end create_join_table


    # begin create_table
    def create_table( self, table_name = None, type_id = None, options = {} ):
        """Creates a new table or collection in GPUdb. If a new table is being created
        then type of the table is given by input parameter *type_id* which must
        the be the type id of a currently registered type (i.e. one created via
        :ref:`create_type <create_type_python>`). The table will be created
        inside a collection if the option *collection_name* is specified. If
        that collection does not already exist then it will be created. To
        create a new, empty collection specify the collection name in input
        parameter *table_name*, leave input parameter *type_id* blank, and set
        the *is_collection* option to 'true'."""

        assert isinstance( table_name, (str, unicode)), "create_table(): Argument 'table_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( table_name ).__name__
        assert isinstance( type_id, (str, unicode)), "create_table(): Argument 'type_id' must be (one) of type(s) '(str, unicode)'; given %s" % type( type_id ).__name__
        assert isinstance( options, (dict)), "create_table(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "create_table" )

        obj = collections.OrderedDict()
        obj['table_name'] = table_name
        obj['type_id'] = type_id
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/create/table' )
    # end create_table


    # begin create_table_monitor
    def create_table_monitor( self, table_name = None, options = {} ):
        """Creates a monitor that watches for new records inserted into a particular
        table (identified by input parameter *table_name*) and forwards copies
        to subscribers via ZMQ. After this call completes, subscribe to the
        returned output parameter *topic_id* on the GPUdb ZMQ table monitor port
        (default 9002). Each time an insert operation on the table completes, a
        multipart message is published for that topic; the first part contains
        only the topic ID, and each subsequent part contains one binary-encoded
        Avro object that was inserted. The monitor will continue to run
        (regardless of whether or not there are any subscribers) until
        deactivated with :ref:`clear_table_monitor
        <clear_tablemonitor_python>`."""

        assert isinstance( table_name, (str, unicode)), "create_table_monitor(): Argument 'table_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( table_name ).__name__
        assert isinstance( options, (dict)), "create_table_monitor(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "create_table_monitor" )

        obj = collections.OrderedDict()
        obj['table_name'] = table_name
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/create/tablemonitor' )
    # end create_table_monitor


    # begin create_trigger_by_area
    def create_trigger_by_area( self, request_id = None, table_names = None,
                                x_column_name = None, x_vector = None,
                                y_column_name = None, y_vector = None, options =
                                {} ):
        """Sets up an area  trigger mechanism for two column_names for one or more
        tables. (This function is essentially the two-dimensional version of
        :ref:`create_trigger_by_range <create_trigger_byrange_python>`.) Once
        the trigger has been activated, any record added to the listed tables(s)
        via :ref:`insert_records <insert_records_python>` with the chosen
        columns' values falling within the specified region will trip the
        trigger. All such records will be queued at GPUdb's trigger port-by
        default '9001' but can also be obtained via :ref:`show_system_status
        <show_system_status_python>`-for any listening client to collect. Active
        triggers can be cancelled by using the :ref:`clear_trigger
        <clear_trigger_python>` endpoint or by clearing all relevant tables.
        The output returns the trigger handle as well as indicating success or
        failure of the trigger activation."""

        assert isinstance( request_id, (str, unicode)), "create_trigger_by_area(): Argument 'request_id' must be (one) of type(s) '(str, unicode)'; given %s" % type( request_id ).__name__
        assert isinstance( table_names, (list)), "create_trigger_by_area(): Argument 'table_names' must be (one) of type(s) '(list)'; given %s" % type( table_names ).__name__
        assert isinstance( x_column_name, (str, unicode)), "create_trigger_by_area(): Argument 'x_column_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( x_column_name ).__name__
        assert isinstance( x_vector, (list)), "create_trigger_by_area(): Argument 'x_vector' must be (one) of type(s) '(list)'; given %s" % type( x_vector ).__name__
        assert isinstance( y_column_name, (str, unicode)), "create_trigger_by_area(): Argument 'y_column_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( y_column_name ).__name__
        assert isinstance( y_vector, (list)), "create_trigger_by_area(): Argument 'y_vector' must be (one) of type(s) '(list)'; given %s" % type( y_vector ).__name__
        assert isinstance( options, (dict)), "create_trigger_by_area(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "create_trigger_by_area" )

        obj = collections.OrderedDict()
        obj['request_id'] = request_id
        obj['table_names'] = table_names
        obj['x_column_name'] = x_column_name
        obj['x_vector'] = x_vector
        obj['y_column_name'] = y_column_name
        obj['y_vector'] = y_vector
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/create/trigger/byarea' )
    # end create_trigger_by_area


    # begin create_trigger_by_range
    def create_trigger_by_range( self, request_id = None, table_names = None,
                                 column_name = None, _min = None, _max = None,
                                 options = {} ):
        """Sets up a simple range trigger for a column_name for one or more tables. Once
        the trigger has been activated, any record added to the listed tables(s)
        via :ref:`insert_records <insert_records_python>` with the chosen
        column_name's value falling within the specified range will trip the
        trigger. All such records will be queued at GPUdb's trigger port-by
        default '9001' but can also be obtained via :ref:`show_system_status
        <show_system_status_python>`-for any listening client to collect. Active
        triggers can be cancelled by using the :ref:`clear_trigger
        <clear_trigger_python>` endpoint or by clearing all relevant tables.
        The output returns the trigger handle as well as indicating success or
        failure of the trigger activation."""

        assert isinstance( request_id, (str, unicode)), "create_trigger_by_range(): Argument 'request_id' must be (one) of type(s) '(str, unicode)'; given %s" % type( request_id ).__name__
        assert isinstance( table_names, (list)), "create_trigger_by_range(): Argument 'table_names' must be (one) of type(s) '(list)'; given %s" % type( table_names ).__name__
        assert isinstance( column_name, (str, unicode)), "create_trigger_by_range(): Argument 'column_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( column_name ).__name__
        assert isinstance( _min, (int, long, float)), "create_trigger_by_range(): Argument '_min' must be (one) of type(s) '(int, long, float)'; given %s" % type( _min ).__name__
        assert isinstance( _max, (int, long, float)), "create_trigger_by_range(): Argument '_max' must be (one) of type(s) '(int, long, float)'; given %s" % type( _max ).__name__
        assert isinstance( options, (dict)), "create_trigger_by_range(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "create_trigger_by_range" )

        obj = collections.OrderedDict()
        obj['request_id'] = request_id
        obj['table_names'] = table_names
        obj['column_name'] = column_name
        obj['min'] = _min
        obj['max'] = _max
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/create/trigger/byrange' )
    # end create_trigger_by_range


    # begin create_type
    def create_type( self, type_definition = None, label = None, properties = {},
                     options = {} ):
        """Creates a new type in GPUdb describing the layout or schema of a table. The
        type definition is a JSON string describing the fields (i.e. columns) of
        the type. Each field consists of a name and a data type. Supported data
        types are: double, float, int, long, string, and bytes. In addition one
        or more properties can be specified for each column which customize the
        memory usage and query availability of that column.      Described below
        are some viable configurations of properties for various types of
        columns:      .. csv-table::         :header: "column Type", "Permitted
        Properties Combination"         :widths: 15, 60          "Numeric",
        "'data' (default if no property is provided for a numeric column)"
        "Numeric", "'store_only'"         "String", "'data' (default if no
        property is provided for a string column)"         "String",
        "'text_search' (persists the data and disables all queries except the
        filter by string query (with the 'search' mode); i.e. implied
        'store_only')"         "String", "'store_only'"         "String",
        "'data', 'text_search'"         "String", "'text_search', 'store_only'"
        "String", "'data', 'disk_optimized'"         "String", "'data',
        'text_search', 'disk_optimized'"         "bytes", "'store_only'"      To
        set a *primary key* on one or more columns include the property
        'primary_key' on the desired column_names. If a primary key is specified
        then GPUdb enforces a uniqueness constraint in that only a single object
        can exist with a given primary key. When :ref:`inserting
        <insert_records_python>` data into a table with a primary key, depending
        on the parameters in the request, incoming objects with primary keys
        that match existing objects will either overwrite (i.e. update) the
        existing object or will be skipped and not added into the set.
        Examples of a type definition with some of the parameters:      Type
        definition::          {"type":"record",         "name":"point",
        "fields":[{"name":"msg_id","type":"string"},
        {"name":"x","type":"double"},
        {"name":"y","type":"double"},
        {"name":"TIMESTAMP","type":"double"},
        {"name":"source","type":"string"},
        {"name":"group_id","type":"string"},
        {"name":"OBJECT_ID","type":"string"}]         }  Properties::
        {"group_id":["store_only"],
        "msg_id":["store_only","text_search"]         }"""

        assert isinstance( type_definition, (str, unicode)), "create_type(): Argument 'type_definition' must be (one) of type(s) '(str, unicode)'; given %s" % type( type_definition ).__name__
        assert isinstance( label, (str, unicode)), "create_type(): Argument 'label' must be (one) of type(s) '(str, unicode)'; given %s" % type( label ).__name__
        assert isinstance( properties, (dict)), "create_type(): Argument 'properties' must be (one) of type(s) '(dict)'; given %s" % type( properties ).__name__
        assert isinstance( options, (dict)), "create_type(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "create_type" )

        obj = collections.OrderedDict()
        obj['type_definition'] = type_definition
        obj['label'] = label
        obj['properties'] = properties
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/create/type' )
    # end create_type


    # begin delete_records
    def delete_records( self, table_name = None, expressions = None, options = {} ):
        """Deletes record(s) matching the provided criteria from the given table. The
        record selection criteria can either be one or more  input parameter
        *expressions* (matching multiple records) or a single record identified
        by *record_id* optiona.  Note that the two selection criteria are
        mutually exclusive.  This operation cannot be run on a collection or a
        view.  The operation is synchronous meaning that a response will not be
        available until the request is completely processed and all the matching
        records are deleted."""

        assert isinstance( table_name, (str, unicode)), "delete_records(): Argument 'table_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( table_name ).__name__
        assert isinstance( expressions, (list)), "delete_records(): Argument 'expressions' must be (one) of type(s) '(list)'; given %s" % type( expressions ).__name__
        assert isinstance( options, (dict)), "delete_records(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "delete_records" )

        obj = collections.OrderedDict()
        obj['table_name'] = table_name
        obj['expressions'] = expressions
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/delete/records' )
    # end delete_records


    # begin filter
    def filter( self, table_name = None, view_name = '', expression = None, options
                = {} ):
        """Filters data based on the specified expression.  The results are stored in a
        result set with the given input parameter *view_name*.  For details see
        `concepts <../../concepts/index.html#expressions>`_.  The response
        message contains the number of points for which the expression evaluated
        to be true, which is equivalent to the size of the result view."""

        assert isinstance( table_name, (str, unicode)), "filter(): Argument 'table_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( table_name ).__name__
        assert isinstance( view_name, (str, unicode)), "filter(): Argument 'view_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( view_name ).__name__
        assert isinstance( expression, (str, unicode)), "filter(): Argument 'expression' must be (one) of type(s) '(str, unicode)'; given %s" % type( expression ).__name__
        assert isinstance( options, (dict)), "filter(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "filter" )

        obj = collections.OrderedDict()
        obj['table_name'] = table_name
        obj['view_name'] = view_name
        obj['expression'] = expression
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/filter' )
    # end filter


    # begin filter_by_area
    def filter_by_area( self, table_name = None, view_name = '', x_column_name =
                        None, x_vector = None, y_column_name = None, y_vector =
                        None, options = {} ):
        """Calculates which objects from a table are within a named area of interest
        (NAI/polygon). The operation is synchronous meaning that GPUdb will not
        return the request until all the matching objects are fully available.
        The response payload provides the count of the resulting set. A new
        resultant set (view) which satisfies the input NAI restriction
        specification is created with the name input parameter *view_name*
        passed in as part of the input."""

        assert isinstance( table_name, (str, unicode)), "filter_by_area(): Argument 'table_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( table_name ).__name__
        assert isinstance( view_name, (str, unicode)), "filter_by_area(): Argument 'view_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( view_name ).__name__
        assert isinstance( x_column_name, (str, unicode)), "filter_by_area(): Argument 'x_column_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( x_column_name ).__name__
        assert isinstance( x_vector, (list)), "filter_by_area(): Argument 'x_vector' must be (one) of type(s) '(list)'; given %s" % type( x_vector ).__name__
        assert isinstance( y_column_name, (str, unicode)), "filter_by_area(): Argument 'y_column_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( y_column_name ).__name__
        assert isinstance( y_vector, (list)), "filter_by_area(): Argument 'y_vector' must be (one) of type(s) '(list)'; given %s" % type( y_vector ).__name__
        assert isinstance( options, (dict)), "filter_by_area(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "filter_by_area" )

        obj = collections.OrderedDict()
        obj['table_name'] = table_name
        obj['view_name'] = view_name
        obj['x_column_name'] = x_column_name
        obj['x_vector'] = x_vector
        obj['y_column_name'] = y_column_name
        obj['y_vector'] = y_vector
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/filter/byarea' )
    # end filter_by_area


    # begin filter_by_box
    def filter_by_box( self, table_name = None, view_name = '', x_column_name =
                       None, min_x = None, max_x = None, y_column_name = None,
                       min_y = None, max_y = None, options = {} ):
        """Calculates how many objects within the given table lie in a rectangular box.
        The operation is synchronous meaning that GPUdb will not return the
        request until all the objects are fully available. The response payload
        provides the count of the resulting set. A new resultant set which
        satisfies the input NAI restriction specification is also created when a
        input parameter *view_name* is passed in as part of the input
        payload."""

        assert isinstance( table_name, (str, unicode)), "filter_by_box(): Argument 'table_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( table_name ).__name__
        assert isinstance( view_name, (str, unicode)), "filter_by_box(): Argument 'view_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( view_name ).__name__
        assert isinstance( x_column_name, (str, unicode)), "filter_by_box(): Argument 'x_column_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( x_column_name ).__name__
        assert isinstance( min_x, (int, long, float)), "filter_by_box(): Argument 'min_x' must be (one) of type(s) '(int, long, float)'; given %s" % type( min_x ).__name__
        assert isinstance( max_x, (int, long, float)), "filter_by_box(): Argument 'max_x' must be (one) of type(s) '(int, long, float)'; given %s" % type( max_x ).__name__
        assert isinstance( y_column_name, (str, unicode)), "filter_by_box(): Argument 'y_column_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( y_column_name ).__name__
        assert isinstance( min_y, (int, long, float)), "filter_by_box(): Argument 'min_y' must be (one) of type(s) '(int, long, float)'; given %s" % type( min_y ).__name__
        assert isinstance( max_y, (int, long, float)), "filter_by_box(): Argument 'max_y' must be (one) of type(s) '(int, long, float)'; given %s" % type( max_y ).__name__
        assert isinstance( options, (dict)), "filter_by_box(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "filter_by_box" )

        obj = collections.OrderedDict()
        obj['table_name'] = table_name
        obj['view_name'] = view_name
        obj['x_column_name'] = x_column_name
        obj['min_x'] = min_x
        obj['max_x'] = max_x
        obj['y_column_name'] = y_column_name
        obj['min_y'] = min_y
        obj['max_y'] = max_y
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/filter/bybox' )
    # end filter_by_box


    # begin filter_by_geometry
    def filter_by_geometry( self, table_name = None, view_name = '', column_name =
                            None, input_wkt = '', operation = None, options = {}
                            ):
        """Applies a geometry filter against a spatial column in a given table,
        collection or view. The filtering geometry is provided by input
        parameter *input_wkt*."""

        assert isinstance( table_name, (str, unicode)), "filter_by_geometry(): Argument 'table_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( table_name ).__name__
        assert isinstance( view_name, (str, unicode)), "filter_by_geometry(): Argument 'view_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( view_name ).__name__
        assert isinstance( column_name, (str, unicode)), "filter_by_geometry(): Argument 'column_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( column_name ).__name__
        assert isinstance( input_wkt, (str, unicode)), "filter_by_geometry(): Argument 'input_wkt' must be (one) of type(s) '(str, unicode)'; given %s" % type( input_wkt ).__name__
        assert isinstance( operation, (str, unicode)), "filter_by_geometry(): Argument 'operation' must be (one) of type(s) '(str, unicode)'; given %s" % type( operation ).__name__
        assert isinstance( options, (dict)), "filter_by_geometry(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "filter_by_geometry" )

        obj = collections.OrderedDict()
        obj['table_name'] = table_name
        obj['view_name'] = view_name
        obj['column_name'] = column_name
        obj['input_wkt'] = input_wkt
        obj['operation'] = operation
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/filter/bygeometry' )
    # end filter_by_geometry


    # begin filter_by_list
    def filter_by_list( self, table_name = None, view_name = '', column_values_map =
                        None, options = {} ):
        """Calculates which records from a table have values in the given list for the
        corresponding column. The operation is synchronous meaning that GPUdb
        will not return a response until all the objects are fully available.
        The response payload provides the count of the resulting set. A new
        resultant set (view) which satisfies the input filter specification is
        also created if a input parameter *view_name* is passed in as part of
        the request.  For example, if a type definition has the columns 'x' and
        'y', then a filter by list query with the column map {"x":["10.1",
        "2.3"], "y":["0.0", "-31.5", "42.0"]} will return the count of all data
        points whose x and y values match one of the values in the respective x-
        and y-lists."""

        assert isinstance( table_name, (str, unicode)), "filter_by_list(): Argument 'table_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( table_name ).__name__
        assert isinstance( view_name, (str, unicode)), "filter_by_list(): Argument 'view_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( view_name ).__name__
        assert isinstance( column_values_map, (dict)), "filter_by_list(): Argument 'column_values_map' must be (one) of type(s) '(dict)'; given %s" % type( column_values_map ).__name__
        assert isinstance( options, (dict)), "filter_by_list(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "filter_by_list" )

        obj = collections.OrderedDict()
        obj['table_name'] = table_name
        obj['view_name'] = view_name
        obj['column_values_map'] = column_values_map
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/filter/bylist' )
    # end filter_by_list


    # begin filter_by_radius
    def filter_by_radius( self, table_name = None, view_name = '', x_column_name =
                          None, x_center = None, y_column_name = None, y_center
                          = None, radius = None, options = {} ):
        """Calculates which objects from a table lie within a circle with the given
        radius and center point (i.e. circular NAI). The operation is
        synchronous meaning that GPUdb will not return a response until all the
        objects are fully available. The response payload provides the count of
        the resulting set. A new resultant set (view) which satisfies the input
        circular NAI restriction specification is also created if a input
        parameter *view_name* is passed in as part of the request.  For track
        data, all track points that lie within the circle plus one point on
        either side of the circle (if the track goes beyond the circle) will be
        included in the result. For shapes, e.g. polygons, all polygons that
        intersect the circle will be included (even if none of the points of the
        polygon fall within the circle)."""

        assert isinstance( table_name, (str, unicode)), "filter_by_radius(): Argument 'table_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( table_name ).__name__
        assert isinstance( view_name, (str, unicode)), "filter_by_radius(): Argument 'view_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( view_name ).__name__
        assert isinstance( x_column_name, (str, unicode)), "filter_by_radius(): Argument 'x_column_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( x_column_name ).__name__
        assert isinstance( x_center, (int, long, float)), "filter_by_radius(): Argument 'x_center' must be (one) of type(s) '(int, long, float)'; given %s" % type( x_center ).__name__
        assert isinstance( y_column_name, (str, unicode)), "filter_by_radius(): Argument 'y_column_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( y_column_name ).__name__
        assert isinstance( y_center, (int, long, float)), "filter_by_radius(): Argument 'y_center' must be (one) of type(s) '(int, long, float)'; given %s" % type( y_center ).__name__
        assert isinstance( radius, (int, long, float)), "filter_by_radius(): Argument 'radius' must be (one) of type(s) '(int, long, float)'; given %s" % type( radius ).__name__
        assert isinstance( options, (dict)), "filter_by_radius(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "filter_by_radius" )

        obj = collections.OrderedDict()
        obj['table_name'] = table_name
        obj['view_name'] = view_name
        obj['x_column_name'] = x_column_name
        obj['x_center'] = x_center
        obj['y_column_name'] = y_column_name
        obj['y_center'] = y_center
        obj['radius'] = radius
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/filter/byradius' )
    # end filter_by_radius


    # begin filter_by_range
    def filter_by_range( self, table_name = None, view_name = '', column_name =
                         None, lower_bound = None, upper_bound = None, options =
                         {} ):
        """Calculates which objects from a table have a column that is within the given
        bounds. An object from the table identified by input parameter
        *table_name* is added to the view input parameter *view_name* if its
        column is within [input parameter *lower_bound*, input parameter
        *upper_bound*] (inclusive). The operation is synchronous. The response
        provides a count of the number of objects which passed the bound filter.
        For track objects, the count reflects how many points fall within the
        given bounds (which may not include all the track points of any given
        track)."""

        assert isinstance( table_name, (str, unicode)), "filter_by_range(): Argument 'table_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( table_name ).__name__
        assert isinstance( view_name, (str, unicode)), "filter_by_range(): Argument 'view_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( view_name ).__name__
        assert isinstance( column_name, (str, unicode)), "filter_by_range(): Argument 'column_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( column_name ).__name__
        assert isinstance( lower_bound, (int, long, float)), "filter_by_range(): Argument 'lower_bound' must be (one) of type(s) '(int, long, float)'; given %s" % type( lower_bound ).__name__
        assert isinstance( upper_bound, (int, long, float)), "filter_by_range(): Argument 'upper_bound' must be (one) of type(s) '(int, long, float)'; given %s" % type( upper_bound ).__name__
        assert isinstance( options, (dict)), "filter_by_range(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "filter_by_range" )

        obj = collections.OrderedDict()
        obj['table_name'] = table_name
        obj['view_name'] = view_name
        obj['column_name'] = column_name
        obj['lower_bound'] = lower_bound
        obj['upper_bound'] = upper_bound
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/filter/byrange' )
    # end filter_by_range


    # begin filter_by_series
    def filter_by_series( self, table_name = None, view_name = '', track_id = None,
                          target_track_ids = None, options = {} ):
        """Filters objects matching all points of the given track (works only on track
        type data).  It allows users to specify a particular track to find all
        other points in the table that fall within specified ranges-spatial and
        temporal-of all points of the given track. Additionally, the user can
        specify another track to see if the two intersect (or go close to each
        other within the specified ranges). The user also has the flexibility of
        using different metrics for the spatial distance calculation: Euclidean
        (flat geometry) or Great Circle (spherical geometry to approximate the
        Earth's surface distances). The filtered points are stored in a newly
        created result set. The return value of the function is the number of
        points in the resultant set (view).  This operation is synchronous
        meaning that GPUdb will not return a response until all the objects are
        fully available."""

        assert isinstance( table_name, (str, unicode)), "filter_by_series(): Argument 'table_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( table_name ).__name__
        assert isinstance( view_name, (str, unicode)), "filter_by_series(): Argument 'view_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( view_name ).__name__
        assert isinstance( track_id, (str, unicode)), "filter_by_series(): Argument 'track_id' must be (one) of type(s) '(str, unicode)'; given %s" % type( track_id ).__name__
        assert isinstance( target_track_ids, (list)), "filter_by_series(): Argument 'target_track_ids' must be (one) of type(s) '(list)'; given %s" % type( target_track_ids ).__name__
        assert isinstance( options, (dict)), "filter_by_series(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "filter_by_series" )

        obj = collections.OrderedDict()
        obj['table_name'] = table_name
        obj['view_name'] = view_name
        obj['track_id'] = track_id
        obj['target_track_ids'] = target_track_ids
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/filter/byseries' )
    # end filter_by_series


    # begin filter_by_string
    def filter_by_string( self, table_name = None, view_name = '', expression =
                          None, mode = None, column_names = None, options = {}
                          ):
        """Calculates which objects from a table, collection or view match a string
        expression for the given string columns. The 'mode' may be:
        'search' for full text search query with wildcards and boolean
        operators, e.g. '(bob* OR sue) AND NOT jane'. Note that for this mode,
        no column can be specified in input parameter *column_names*; GPUdb will
        search through all string columns of the table that have text search
        enabled. Also, the first character of the regular expression cannot be a
        wildcard (* or ?).  * 'equals' for an exact whole-string match *
        'contains' for a partial substring match (not accelerated) *
        'starts_with' to find strings that start with the given expression (not
        accelerated) * 'regex' - to use a full regular expression search (not
        accelerated)  The options 'case_sensitive' can be used to modify the
        behavior for all modes except 'search'"""

        assert isinstance( table_name, (str, unicode)), "filter_by_string(): Argument 'table_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( table_name ).__name__
        assert isinstance( view_name, (str, unicode)), "filter_by_string(): Argument 'view_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( view_name ).__name__
        assert isinstance( expression, (str, unicode)), "filter_by_string(): Argument 'expression' must be (one) of type(s) '(str, unicode)'; given %s" % type( expression ).__name__
        assert isinstance( mode, (str, unicode)), "filter_by_string(): Argument 'mode' must be (one) of type(s) '(str, unicode)'; given %s" % type( mode ).__name__
        assert isinstance( column_names, (list)), "filter_by_string(): Argument 'column_names' must be (one) of type(s) '(list)'; given %s" % type( column_names ).__name__
        assert isinstance( options, (dict)), "filter_by_string(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "filter_by_string" )

        obj = collections.OrderedDict()
        obj['table_name'] = table_name
        obj['view_name'] = view_name
        obj['expression'] = expression
        obj['mode'] = mode
        obj['column_names'] = column_names
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/filter/bystring' )
    # end filter_by_string


    # begin filter_by_table
    def filter_by_table( self, table_name = None, view_name = '', column_name =
                         None, source_table_name = None,
                         source_table_column_name = None, options = {} ):
        """Filters objects in one table based on objects in another table. The user must
        specify matching column types from the two tables (i.e. the target table
        from which objects will be filtered and the source table based on which
        the filter will be created); the column names need not be the same. If a
        input parameter *view_name* is specified, then the filtered objects will
        then be put in a newly created view. The operation is synchronous,
        meaning that GPUdb will not return until all objects are fully available
        in the result view. The return value contains the count (i.e. the size)
        of the resulting view."""

        assert isinstance( table_name, (str, unicode)), "filter_by_table(): Argument 'table_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( table_name ).__name__
        assert isinstance( view_name, (str, unicode)), "filter_by_table(): Argument 'view_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( view_name ).__name__
        assert isinstance( column_name, (str, unicode)), "filter_by_table(): Argument 'column_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( column_name ).__name__
        assert isinstance( source_table_name, (str, unicode)), "filter_by_table(): Argument 'source_table_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( source_table_name ).__name__
        assert isinstance( source_table_column_name, (str, unicode)), "filter_by_table(): Argument 'source_table_column_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( source_table_column_name ).__name__
        assert isinstance( options, (dict)), "filter_by_table(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "filter_by_table" )

        obj = collections.OrderedDict()
        obj['table_name'] = table_name
        obj['view_name'] = view_name
        obj['column_name'] = column_name
        obj['source_table_name'] = source_table_name
        obj['source_table_column_name'] = source_table_column_name
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/filter/bytable' )
    # end filter_by_table


    # begin filter_by_value
    def filter_by_value( self, table_name = None, view_name = '', is_string = None,
                         value = 0, value_str = '', column_name = None, options
                         = {} ):
        """Calculates which objects from a table has a particular value for a particular
        column. The input parameters provide a way to specify either a String or
        a Double valued column and a desired value for the column on which the
        filter is performed. The operation is synchronous meaning that GPUdb
        will not return a response until all the objects are fully available.
        The response payload provides the count of the resulting set. A new
        result view which satisfies the input filter restriction specification
        is also created with a view name passed in as part of the input
        payload."""

        assert isinstance( table_name, (str, unicode)), "filter_by_value(): Argument 'table_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( table_name ).__name__
        assert isinstance( view_name, (str, unicode)), "filter_by_value(): Argument 'view_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( view_name ).__name__
        assert isinstance( is_string, (bool)), "filter_by_value(): Argument 'is_string' must be (one) of type(s) '(bool)'; given %s" % type( is_string ).__name__
        assert isinstance( value, (int, long, float)), "filter_by_value(): Argument 'value' must be (one) of type(s) '(int, long, float)'; given %s" % type( value ).__name__
        assert isinstance( value_str, (str, unicode)), "filter_by_value(): Argument 'value_str' must be (one) of type(s) '(str, unicode)'; given %s" % type( value_str ).__name__
        assert isinstance( column_name, (str, unicode)), "filter_by_value(): Argument 'column_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( column_name ).__name__
        assert isinstance( options, (dict)), "filter_by_value(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "filter_by_value" )

        obj = collections.OrderedDict()
        obj['table_name'] = table_name
        obj['view_name'] = view_name
        obj['is_string'] = is_string
        obj['value'] = value
        obj['value_str'] = value_str
        obj['column_name'] = column_name
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/filter/byvalue' )
    # end filter_by_value


    # begin get_records
    def get_records( self, table_name = None, offset = 0, limit = 10000, encoding =
                     'binary', options = {} ):
        """Retrieves records from a given table, optionally filtered by an expression
        and/or sorted by a column. This operation can only be performed on
        tables or on homogeneous collection (collections whose children all have
        the same type). Records can be returned encoded as binary or json.  This
        operation supports paging through the data via the input parameter
        *offset* and input parameter *limit* parameters. Note that when paging
        through a table, if the table (or the underlying table in case of a
        view) is updated (records are inserted, deleted or modified) the records
        retrieved may differ between calls based on the updates applied."""

        assert isinstance( table_name, (str, unicode)), "get_records(): Argument 'table_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( table_name ).__name__
        assert isinstance( offset, (int, long, float)), "get_records(): Argument 'offset' must be (one) of type(s) '(int, long, float)'; given %s" % type( offset ).__name__
        assert isinstance( limit, (int, long, float)), "get_records(): Argument 'limit' must be (one) of type(s) '(int, long, float)'; given %s" % type( limit ).__name__
        assert isinstance( encoding, (str, unicode)), "get_records(): Argument 'encoding' must be (one) of type(s) '(str, unicode)'; given %s" % type( encoding ).__name__
        assert isinstance( options, (dict)), "get_records(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "get_records" )

        obj = collections.OrderedDict()
        obj['table_name'] = table_name
        obj['offset'] = offset
        obj['limit'] = limit
        obj['encoding'] = encoding
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/get/records' )
    # end get_records


    # begin get_records_by_column
    def get_records_by_column( self, table_name = None, column_names = None, offset
                               = None, limit = None, encoding = 'binary',
                               options = {} ):
        """For a given table, retrieves the values of the given columns within a given
        range. It returns maps of column name to the vector of values for each
        supported data type (double, float, long, int and string). This
        operation supports pagination feature, i.e. values that are retrieved
        are those associated with the indices between the start (offset) and end
        value (offset + limit) parameters (inclusive). If there are num_points
        values in the table then each of the indices between 0 and num_points-1
        retrieves a unique value.  Note that when using the pagination feature,
        if the table (or the underlying table in case of a view) is updated
        (records are inserted, deleted or modified) the records or values
        retrieved may differ between calls (discontiguous or overlap) based on
        the type of the update.  The response is returned as a dynamic schema.
        For details see: {dynamic schemas documentation}@{link
        ../../concepts/index.html#dynamic-schemas}."""

        assert isinstance( table_name, (str, unicode)), "get_records_by_column(): Argument 'table_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( table_name ).__name__
        assert isinstance( column_names, (list)), "get_records_by_column(): Argument 'column_names' must be (one) of type(s) '(list)'; given %s" % type( column_names ).__name__
        assert isinstance( offset, (int, long, float)), "get_records_by_column(): Argument 'offset' must be (one) of type(s) '(int, long, float)'; given %s" % type( offset ).__name__
        assert isinstance( limit, (int, long, float)), "get_records_by_column(): Argument 'limit' must be (one) of type(s) '(int, long, float)'; given %s" % type( limit ).__name__
        assert isinstance( encoding, (str, unicode)), "get_records_by_column(): Argument 'encoding' must be (one) of type(s) '(str, unicode)'; given %s" % type( encoding ).__name__
        assert isinstance( options, (dict)), "get_records_by_column(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "get_records_by_column" )

        obj = collections.OrderedDict()
        obj['table_name'] = table_name
        obj['column_names'] = column_names
        obj['offset'] = offset
        obj['limit'] = limit
        obj['encoding'] = encoding
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/get/records/bycolumn' )
    # end get_records_by_column


    # begin get_records_by_series
    def get_records_by_series( self, table_name = None, world_table_name = None,
                               offset = 0, limit = 10000, encoding = 'binary',
                               options = {} ):
        """Retrieves the complete series/track records from the given input parameter
        *world_table_name* based on the partial track informaton contained in
        the input parameter *table_name*.   This operation supports paging
        through the data via the input parameter *offset* and input parameter
        *limit* parameters.  In contrast to :ref:`get_records
        <get_records_python>` this returns records grouped by series/track. So
        if input parameter *offset* is 0 and input parameter *limit* is 5 this
        operation would return the first 5 series/tracks in input parameter
        *table_name*. Each series/track will be returned sorted by their
        TIMESTAMP column."""

        assert isinstance( table_name, (str, unicode)), "get_records_by_series(): Argument 'table_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( table_name ).__name__
        assert isinstance( world_table_name, (str, unicode)), "get_records_by_series(): Argument 'world_table_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( world_table_name ).__name__
        assert isinstance( offset, (int, long, float)), "get_records_by_series(): Argument 'offset' must be (one) of type(s) '(int, long, float)'; given %s" % type( offset ).__name__
        assert isinstance( limit, (int, long, float)), "get_records_by_series(): Argument 'limit' must be (one) of type(s) '(int, long, float)'; given %s" % type( limit ).__name__
        assert isinstance( encoding, (str, unicode)), "get_records_by_series(): Argument 'encoding' must be (one) of type(s) '(str, unicode)'; given %s" % type( encoding ).__name__
        assert isinstance( options, (dict)), "get_records_by_series(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "get_records_by_series" )

        obj = collections.OrderedDict()
        obj['table_name'] = table_name
        obj['world_table_name'] = world_table_name
        obj['offset'] = offset
        obj['limit'] = limit
        obj['encoding'] = encoding
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/get/records/byseries' )
    # end get_records_by_series


    # begin get_records_from_collection
    def get_records_from_collection( self, table_name = None, offset = 0, limit =
                                     10000, encoding = 'binary', options = {} ):
        """Retrieves records from a collection. The operation can optionally return the
        record IDs which can be used in certain queries such as
        :ref:`delete_records <delete_records_python>`.   This operation supports
        paging through the data via the input parameter *offset* and input
        parameter *limit* parameters."""

        assert isinstance( table_name, (str, unicode)), "get_records_from_collection(): Argument 'table_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( table_name ).__name__
        assert isinstance( offset, (int, long, float)), "get_records_from_collection(): Argument 'offset' must be (one) of type(s) '(int, long, float)'; given %s" % type( offset ).__name__
        assert isinstance( limit, (int, long, float)), "get_records_from_collection(): Argument 'limit' must be (one) of type(s) '(int, long, float)'; given %s" % type( limit ).__name__
        assert isinstance( encoding, (str, unicode)), "get_records_from_collection(): Argument 'encoding' must be (one) of type(s) '(str, unicode)'; given %s" % type( encoding ).__name__
        assert isinstance( options, (dict)), "get_records_from_collection(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "get_records_from_collection" )

        obj = collections.OrderedDict()
        obj['table_name'] = table_name
        obj['offset'] = offset
        obj['limit'] = limit
        obj['encoding'] = encoding
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/get/records/fromcollection' )
    # end get_records_from_collection


    # begin has_table
    def has_table( self, table_name = None, options = {} ):
        """Checks the existance of a table with the given name in GPUdb."""

        assert isinstance( table_name, (str, unicode)), "has_table(): Argument 'table_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( table_name ).__name__
        assert isinstance( options, (dict)), "has_table(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "has_table" )

        obj = collections.OrderedDict()
        obj['table_name'] = table_name
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/has/table' )
    # end has_table


    # begin has_type
    def has_type( self, type_id = None, options = {} ):
        """Check the existance of a type in GPUdb."""

        assert isinstance( type_id, (str, unicode)), "has_type(): Argument 'type_id' must be (one) of type(s) '(str, unicode)'; given %s" % type( type_id ).__name__
        assert isinstance( options, (dict)), "has_type(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "has_type" )

        obj = collections.OrderedDict()
        obj['type_id'] = type_id
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/has/type' )
    # end has_type


    # begin insert_records
    def insert_records( self, table_name = None, objects = None, list_encoding =
                        None, options = {} ):
        """Adds multiple records to the specified table. The operation is synchronous
        meaning that GPUdb will not return a response until all the records are
        fully inserted and available. The response payload provides unique
        identifier for each added record along with counts of the number of
        records actually inserted and/or updated.  Input parameter *options* can
        be used to customize this function's behavior. The only parameter
        available is *update_on_existing_pk*. The value can be either 'true' or
        'false'. If the table has a :ref:`primary key <create_type_python>` and
        if *update_on_existing_pk* is 'true' then if any of the records being
        added have the same primary key as existing records, the existing
        records are replaced (i.e. *updated*) with the given records. If
        *update_on_existing_pk* is false and if the records being added have the
        same primary key as existing records, the given records with existing
        primary keys are ignored (the existing records are left unchanged). It
        is quite possible that in this case some of the given records will be
        inserted and some (those having existing primary keys) will be ignored
        (or updated). If the specified table does not have a primary key column
        then the *update_on_existing_pk* option is ignored."""

        assert isinstance( table_name, (str, unicode)), "insert_records(): Argument 'table_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( table_name ).__name__
        assert isinstance( objects, (list)), "insert_records(): Argument 'objects' must be (one) of type(s) '(list)'; given %s" % type( objects ).__name__
        assert isinstance( list_encoding, (str, unicode, type( None ))), "insert_records(): Argument 'list_encoding' must be (one) of type(s) '(str, unicode, type( None ))'; given %s" % type( list_encoding ).__name__
        assert isinstance( options, (dict)), "insert_records(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "insert_records" )

        obj = collections.OrderedDict()
        obj['table_name'] = table_name
        list_encoding = list_encoding if list_encoding else self.client_to_object_encoding()
        obj['list_encoding'] = list_encoding
        if (list_encoding == 'json'):
            obj['list_str'] = objects
            obj['list'] = []
        elif (list_encoding == 'binary'):
            obj['list'] = objects
            obj['list_str'] = []
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/insert/records' )
    # end insert_records


    # begin insert_records_random
    def insert_records_random( self, table_name = None, count = None, options = {}
                               ):
        """Generates a specified number of random records and adds them to the given
        tble. There is an optional parameter that allows the user to customize
        the ranges of the column values. It also allows the user to specify
        linear profiles for some or all columns in which case linear values are
        generated rather than random ones. Only individual tables are supported
        for this operation.  This operation is synchronous, meaning that GPUdb
        will not return until all random records are fully available."""

        assert isinstance( table_name, (str, unicode)), "insert_records_random(): Argument 'table_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( table_name ).__name__
        assert isinstance( count, (int, long, float)), "insert_records_random(): Argument 'count' must be (one) of type(s) '(int, long, float)'; given %s" % type( count ).__name__
        assert isinstance( options, (dict)), "insert_records_random(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "insert_records_random" )

        obj = collections.OrderedDict()
        obj['table_name'] = table_name
        obj['count'] = count
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/insert/records/random' )
    # end insert_records_random


    # begin insert_symbol
    def insert_symbol( self, symbol_id = None, symbol_format = None, symbol_data =
                       None, options = {} ):
        """Adds a symbol or icon (i.e. an image) to represent data points when data is
        rendered visually. Users must provide the symbol identifier (string), a
        format (currently supported: 'svg' and 'svg_path'), the data for the
        symbol, and any additional optional parameter (e.g. color). To have a
        symbol used for rendering create a table with a string column named
        'SYMBOLCODE' (along with 'x' or 'y' for example). Then when the table is
        rendered (via `WMS <../rest/wms_rest.html>`_ or :ref:`visualize_image
        <visualize_image_python>`) if the 'dosymbology' parameter is 'true' then
        GPUdb uses the value of the 'SYMBOLCODE' column to pick the symbol
        displayed for each point."""

        assert isinstance( symbol_id, (str, unicode)), "insert_symbol(): Argument 'symbol_id' must be (one) of type(s) '(str, unicode)'; given %s" % type( symbol_id ).__name__
        assert isinstance( symbol_format, (str, unicode)), "insert_symbol(): Argument 'symbol_format' must be (one) of type(s) '(str, unicode)'; given %s" % type( symbol_format ).__name__
        assert isinstance( symbol_data, (str, unicode)), "insert_symbol(): Argument 'symbol_data' must be (one) of type(s) '(str, unicode)'; given %s" % type( symbol_data ).__name__
        assert isinstance( options, (dict)), "insert_symbol(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "insert_symbol" )

        obj = collections.OrderedDict()
        obj['symbol_id'] = symbol_id
        obj['symbol_format'] = symbol_format
        obj['symbol_data'] = symbol_data
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/insert/symbol' )
    # end insert_symbol


    # begin show_system_properties
    def show_system_properties( self, options = {} ):
        """Returns server configuration and version related information to the caller.
        The GPUdb Admin tool uses it to present server related information to
        the user."""

        assert isinstance( options, (dict)), "show_system_properties(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "show_system_properties" )

        obj = collections.OrderedDict()
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/show/system/properties' )
    # end show_system_properties


    # begin show_system_status
    def show_system_status( self, options = {} ):
        """Provides server configuration and health related status to the caller. The
        GPUdb Admin tool uses it to present server related information to the
        user."""

        assert isinstance( options, (dict)), "show_system_status(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "show_system_status" )

        obj = collections.OrderedDict()
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/show/system/status' )
    # end show_system_status


    # begin show_system_timing
    def show_system_timing( self, options = {} ):
        """Returns the last 100 requests made to GPUdb along with the request timing and
        internal job id. The GPUdb Admin tool uses it to present request timing
        information to the user."""

        assert isinstance( options, (dict)), "show_system_timing(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "show_system_timing" )

        obj = collections.OrderedDict()
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/show/system/timing' )
    # end show_system_timing


    # begin show_table
    def show_table( self, table_name = None, options = {} ):
        """Retrieves detailed information about a particular GPUdb table, specified in
        input parameter *table_name*. If the supplied input parameter
        *table_name* is a collection, the call returns a list of tables
        contained in the collection, and for each table it returns the type ids,
        type schemas, type labels, semantic types, and ttls. If the option
        'get_sizes' is set to 'true' then  the sizes (objects and elements) of
        each table are returned (in output parameter *sizes* and output
        parameter *full_sizes*), along with the total number of objects in the
        requested table (in output parameter *total_size* and output parameter
        *total_full_size*).  If the requested table is blank, then information
        is returned about all top-level tables including collections. In this
        case output parameter *is_collection* indicates which of the returned
        table names are collections."""

        assert isinstance( table_name, (str, unicode)), "show_table(): Argument 'table_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( table_name ).__name__
        assert isinstance( options, (dict)), "show_table(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "show_table" )

        obj = collections.OrderedDict()
        obj['table_name'] = table_name
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/show/table' )
    # end show_table


    # begin show_table_metadata
    def show_table_metadata( self, table_names = None, options = {} ):
        """Retrieves the user provided metadata for the specified tables."""

        assert isinstance( table_names, (list)), "show_table_metadata(): Argument 'table_names' must be (one) of type(s) '(list)'; given %s" % type( table_names ).__name__
        assert isinstance( options, (dict)), "show_table_metadata(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "show_table_metadata" )

        obj = collections.OrderedDict()
        obj['table_names'] = table_names
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/show/table/metadata' )
    # end show_table_metadata


    # begin show_table_properties
    def show_table_properties( self, table_names = None, options = {} ):
        """Retrieves some table properties for each of the specified tables. For each
        valid table, it returns whether it is a protected table and also if it
        allows duplicate child tables if it happens to be a collection."""

        assert isinstance( table_names, (list)), "show_table_properties(): Argument 'table_names' must be (one) of type(s) '(list)'; given %s" % type( table_names ).__name__
        assert isinstance( options, (dict)), "show_table_properties(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "show_table_properties" )

        obj = collections.OrderedDict()
        obj['table_names'] = table_names
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/show/table/properties' )
    # end show_table_properties


    # begin show_tables_by_type
    def show_tables_by_type( self, type_id = None, label = None, options = {} ):
        """Gets names of the tables from GPUdb based on the type information. Each table
        in GPUdb has a particular type. This type is made out of the type label,
        schema of the table and the semantic type of the table. This function
        allows a look up of the existing tables based on full or partial type
        information. The operation is synchronous."""

        assert isinstance( type_id, (str, unicode)), "show_tables_by_type(): Argument 'type_id' must be (one) of type(s) '(str, unicode)'; given %s" % type( type_id ).__name__
        assert isinstance( label, (str, unicode)), "show_tables_by_type(): Argument 'label' must be (one) of type(s) '(str, unicode)'; given %s" % type( label ).__name__
        assert isinstance( options, (dict)), "show_tables_by_type(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "show_tables_by_type" )

        obj = collections.OrderedDict()
        obj['type_id'] = type_id
        obj['label'] = label
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/show/tables/bytype' )
    # end show_tables_by_type


    # begin show_triggers
    def show_triggers( self, trigger_ids = None, options = {} ):
        """Retrieves information regarding the specified triggers or all existing
        triggers currently active within GPUdb."""

        assert isinstance( trigger_ids, (list)), "show_triggers(): Argument 'trigger_ids' must be (one) of type(s) '(list)'; given %s" % type( trigger_ids ).__name__
        assert isinstance( options, (dict)), "show_triggers(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "show_triggers" )

        obj = collections.OrderedDict()
        obj['trigger_ids'] = trigger_ids
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/show/triggers' )
    # end show_triggers


    # begin show_types
    def show_types( self, type_id = None, label = None, options = {} ):
        """Retrieves information for the specified data type. Given a type ID, GPUdb
        returns the data type schema, the label, and the semantic type along
        with the type ID. If the user provides any combination of label and
        semantic type, then GPUdb returns the pertinent information for all data
        types that match the input criteria."""

        assert isinstance( type_id, (str, unicode)), "show_types(): Argument 'type_id' must be (one) of type(s) '(str, unicode)'; given %s" % type( type_id ).__name__
        assert isinstance( label, (str, unicode)), "show_types(): Argument 'label' must be (one) of type(s) '(str, unicode)'; given %s" % type( label ).__name__
        assert isinstance( options, (dict)), "show_types(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "show_types" )

        obj = collections.OrderedDict()
        obj['type_id'] = type_id
        obj['label'] = label
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/show/types' )
    # end show_types


    # begin update_records
    def update_records( self, table_name = None, expressions = None, new_values_maps
                        = None, records_to_insert = [], records_to_insert_str =
                        [], record_encoding = 'binary', options = {} ):
        """Runs multiple predicate-based updates in a single call.  With the list of
        given expressions, any matching record's column values will be updated
        as provided in input parameter *new_values_maps*.  There is also an
        optional 'upsert' capability where if a particular predicate doesn't
        match any existing record, then a new record can be inserted.  Note that
        this operation can only be run on an original table and not on a
        collection or a result view.  This operation can update primary key
        values.  By default only 'pure primary key' predicates are allowed when
        updating primary key values. If the primary key for a table is the
        column 'attr1', then the operation will only accept predicates of the
        form: "attr1 == 'foo'" if the attr1 column is being updated.  For a
        composite primary key (e.g. columns 'attr1' and 'attr2') then this
        operation will only accept predicates of the form: "(attr1 == 'foo') and
        (attr2 == 'bar')".  Meaning, all primary key columns must appear in an
        equality predicate in the expressions.  Furthermore each 'pure primary
        key' predicate must be unique within a given request.  These
        restrictions can be removed by utilizing some available options through
        input parameter *options*."""

        assert isinstance( table_name, (str, unicode)), "update_records(): Argument 'table_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( table_name ).__name__
        assert isinstance( expressions, (list)), "update_records(): Argument 'expressions' must be (one) of type(s) '(list)'; given %s" % type( expressions ).__name__
        assert isinstance( new_values_maps, (list)), "update_records(): Argument 'new_values_maps' must be (one) of type(s) '(list)'; given %s" % type( new_values_maps ).__name__
        assert isinstance( records_to_insert, (list)), "update_records(): Argument 'records_to_insert' must be (one) of type(s) '(list)'; given %s" % type( records_to_insert ).__name__
        assert isinstance( records_to_insert_str, (list)), "update_records(): Argument 'records_to_insert_str' must be (one) of type(s) '(list)'; given %s" % type( records_to_insert_str ).__name__
        assert isinstance( record_encoding, (str, unicode)), "update_records(): Argument 'record_encoding' must be (one) of type(s) '(str, unicode)'; given %s" % type( record_encoding ).__name__
        assert isinstance( options, (dict)), "update_records(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "update_records" )

        obj = collections.OrderedDict()
        obj['table_name'] = table_name
        obj['expressions'] = expressions
        obj['new_values_maps'] = new_values_maps
        obj['records_to_insert'] = records_to_insert
        obj['records_to_insert_str'] = records_to_insert_str
        obj['record_encoding'] = record_encoding
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/update/records' )
    # end update_records


    # begin update_records_by_series
    def update_records_by_series( self, table_name = None, world_table_name = None,
                                  view_name = '', reserved = [], options = {} ):
        """Updates the view specified by input parameter *table_name* to include full
        series (track) information from the input parameter *world_table_name*
        for the series (tracks) present in the input parameter *view_name*."""

        assert isinstance( table_name, (str, unicode)), "update_records_by_series(): Argument 'table_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( table_name ).__name__
        assert isinstance( world_table_name, (str, unicode)), "update_records_by_series(): Argument 'world_table_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( world_table_name ).__name__
        assert isinstance( view_name, (str, unicode)), "update_records_by_series(): Argument 'view_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( view_name ).__name__
        assert isinstance( reserved, (list)), "update_records_by_series(): Argument 'reserved' must be (one) of type(s) '(list)'; given %s" % type( reserved ).__name__
        assert isinstance( options, (dict)), "update_records_by_series(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "update_records_by_series" )

        obj = collections.OrderedDict()
        obj['table_name'] = table_name
        obj['world_table_name'] = world_table_name
        obj['view_name'] = view_name
        obj['reserved'] = reserved
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/update/records/byseries' )
    # end update_records_by_series


    # begin visualize_image
    def visualize_image( self, table_names = None, world_table_names = None,
                         x_column_name = None, y_column_name = None, track_ids =
                         None, min_x = None, max_x = None, min_y = None, max_y =
                         None, width = None, height = None, projection =
                         'PLATE_CARREE', bg_color = None, do_points = 'true',
                         do_shapes = 'true', do_tracks = 'true', do_symbology =
                         'false', pointcolors = None, pointsizes = '3',
                         pointshapes = None, shapelinewidths = '3',
                         shapelinecolors = 'FFFF00 ', shapefillcolors = '-1',
                         tracklinewidths = '3', tracklinecolors = 'green',
                         trackmarkersizes = '3', trackmarkercolors = '0000FF',
                         trackmarkershapes = 'none', trackheadcolors = 'FFFFFF',
                         trackheadsizes = '10', trackheadshapes = 'circle',
                         options = {} ):
        """Generates 'class break' rasterized image tiles for an area of interest using
        the given tables and the provided parameters.  All color values must be
        in the format RRGGBB or AARRGGBB (to specify the alpha value)."""

        assert isinstance( table_names, (list)), "visualize_image(): Argument 'table_names' must be (one) of type(s) '(list)'; given %s" % type( table_names ).__name__
        assert isinstance( world_table_names, (list)), "visualize_image(): Argument 'world_table_names' must be (one) of type(s) '(list)'; given %s" % type( world_table_names ).__name__
        assert isinstance( x_column_name, (str, unicode)), "visualize_image(): Argument 'x_column_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( x_column_name ).__name__
        assert isinstance( y_column_name, (str, unicode)), "visualize_image(): Argument 'y_column_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( y_column_name ).__name__
        assert isinstance( track_ids, (list)), "visualize_image(): Argument 'track_ids' must be (one) of type(s) '(list)'; given %s" % type( track_ids ).__name__
        assert isinstance( min_x, (int, long, float)), "visualize_image(): Argument 'min_x' must be (one) of type(s) '(int, long, float)'; given %s" % type( min_x ).__name__
        assert isinstance( max_x, (int, long, float)), "visualize_image(): Argument 'max_x' must be (one) of type(s) '(int, long, float)'; given %s" % type( max_x ).__name__
        assert isinstance( min_y, (int, long, float)), "visualize_image(): Argument 'min_y' must be (one) of type(s) '(int, long, float)'; given %s" % type( min_y ).__name__
        assert isinstance( max_y, (int, long, float)), "visualize_image(): Argument 'max_y' must be (one) of type(s) '(int, long, float)'; given %s" % type( max_y ).__name__
        assert isinstance( width, (int, long, float)), "visualize_image(): Argument 'width' must be (one) of type(s) '(int, long, float)'; given %s" % type( width ).__name__
        assert isinstance( height, (int, long, float)), "visualize_image(): Argument 'height' must be (one) of type(s) '(int, long, float)'; given %s" % type( height ).__name__
        assert isinstance( projection, (str, unicode)), "visualize_image(): Argument 'projection' must be (one) of type(s) '(str, unicode)'; given %s" % type( projection ).__name__
        assert isinstance( bg_color, (int, long, float)), "visualize_image(): Argument 'bg_color' must be (one) of type(s) '(int, long, float)'; given %s" % type( bg_color ).__name__
        assert isinstance( do_points, (list)), "visualize_image(): Argument 'do_points' must be (one) of type(s) '(list)'; given %s" % type( do_points ).__name__
        assert isinstance( do_shapes, (list)), "visualize_image(): Argument 'do_shapes' must be (one) of type(s) '(list)'; given %s" % type( do_shapes ).__name__
        assert isinstance( do_tracks, (list)), "visualize_image(): Argument 'do_tracks' must be (one) of type(s) '(list)'; given %s" % type( do_tracks ).__name__
        assert isinstance( do_symbology, (list)), "visualize_image(): Argument 'do_symbology' must be (one) of type(s) '(list)'; given %s" % type( do_symbology ).__name__
        assert isinstance( pointcolors, (list)), "visualize_image(): Argument 'pointcolors' must be (one) of type(s) '(list)'; given %s" % type( pointcolors ).__name__
        assert isinstance( pointsizes, (list)), "visualize_image(): Argument 'pointsizes' must be (one) of type(s) '(list)'; given %s" % type( pointsizes ).__name__
        assert isinstance( pointshapes, (list)), "visualize_image(): Argument 'pointshapes' must be (one) of type(s) '(list)'; given %s" % type( pointshapes ).__name__
        assert isinstance( shapelinewidths, (list)), "visualize_image(): Argument 'shapelinewidths' must be (one) of type(s) '(list)'; given %s" % type( shapelinewidths ).__name__
        assert isinstance( shapelinecolors, (list)), "visualize_image(): Argument 'shapelinecolors' must be (one) of type(s) '(list)'; given %s" % type( shapelinecolors ).__name__
        assert isinstance( shapefillcolors, (list)), "visualize_image(): Argument 'shapefillcolors' must be (one) of type(s) '(list)'; given %s" % type( shapefillcolors ).__name__
        assert isinstance( tracklinewidths, (list)), "visualize_image(): Argument 'tracklinewidths' must be (one) of type(s) '(list)'; given %s" % type( tracklinewidths ).__name__
        assert isinstance( tracklinecolors, (list)), "visualize_image(): Argument 'tracklinecolors' must be (one) of type(s) '(list)'; given %s" % type( tracklinecolors ).__name__
        assert isinstance( trackmarkersizes, (list)), "visualize_image(): Argument 'trackmarkersizes' must be (one) of type(s) '(list)'; given %s" % type( trackmarkersizes ).__name__
        assert isinstance( trackmarkercolors, (list)), "visualize_image(): Argument 'trackmarkercolors' must be (one) of type(s) '(list)'; given %s" % type( trackmarkercolors ).__name__
        assert isinstance( trackmarkershapes, (list)), "visualize_image(): Argument 'trackmarkershapes' must be (one) of type(s) '(list)'; given %s" % type( trackmarkershapes ).__name__
        assert isinstance( trackheadcolors, (list)), "visualize_image(): Argument 'trackheadcolors' must be (one) of type(s) '(list)'; given %s" % type( trackheadcolors ).__name__
        assert isinstance( trackheadsizes, (list)), "visualize_image(): Argument 'trackheadsizes' must be (one) of type(s) '(list)'; given %s" % type( trackheadsizes ).__name__
        assert isinstance( trackheadshapes, (list)), "visualize_image(): Argument 'trackheadshapes' must be (one) of type(s) '(list)'; given %s" % type( trackheadshapes ).__name__
        assert isinstance( options, (dict)), "visualize_image(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "visualize_image" )

        obj = collections.OrderedDict()
        obj['table_names'] = table_names
        obj['world_table_names'] = world_table_names
        obj['x_column_name'] = x_column_name
        obj['y_column_name'] = y_column_name
        obj['track_ids'] = track_ids
        obj['min_x'] = min_x
        obj['max_x'] = max_x
        obj['min_y'] = min_y
        obj['max_y'] = max_y
        obj['width'] = width
        obj['height'] = height
        obj['projection'] = projection
        obj['bg_color'] = bg_color
        obj['do_points'] = do_points
        obj['do_shapes'] = do_shapes
        obj['do_tracks'] = do_tracks
        obj['do_symbology'] = do_symbology
        obj['pointcolors'] = pointcolors
        obj['pointsizes'] = pointsizes
        obj['pointshapes'] = pointshapes
        obj['shapelinewidths'] = shapelinewidths
        obj['shapelinecolors'] = shapelinecolors
        obj['shapefillcolors'] = shapefillcolors
        obj['tracklinewidths'] = tracklinewidths
        obj['tracklinecolors'] = tracklinecolors
        obj['trackmarkersizes'] = trackmarkersizes
        obj['trackmarkercolors'] = trackmarkercolors
        obj['trackmarkershapes'] = trackmarkershapes
        obj['trackheadcolors'] = trackheadcolors
        obj['trackheadsizes'] = trackheadsizes
        obj['trackheadshapes'] = trackheadshapes
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/visualize/image' )
    # end visualize_image


    # begin visualize_image_classbreak
    def visualize_image_classbreak( self, table_names = None, world_table_names =
                                    None, x_column_name = None, y_column_name =
                                    None, track_ids = None, cb_column_name1 =
                                    None, cb_vals1 = None, cb_column_name2 =
                                    None, cb_vals2 = None, min_x = None, max_x =
                                    None, min_y = None, max_y = None, width =
                                    None, height = None, projection =
                                    'PLATE_CARREE', bg_color = None, do_points =
                                    'true', do_shapes = 'true', do_tracks =
                                    'true', do_symbology = 'false', pointcolors
                                    = 'FF0000', pointsizes = '3', pointshapes =
                                    None, shapelinewidths = '3', shapelinecolors
                                    = 'FFFF00 ', shapefillcolors = '-1',
                                    tracklinewidths = '3', tracklinecolors =
                                    'green', trackmarkersizes = '3',
                                    trackmarkercolors = 'blue',
                                    trackmarkershapes = 'none', trackheadcolors
                                    = 'FFFFFF', trackheadsizes = '10',
                                    trackheadshapes = 'circle', options = {} ):
        """Generates 'class break' rasterized image tiles for an area of interest using
        the given tables and the provided parameters.  A class break rendering
        is where data from one or more GPUdb tables is rasterized with styling
        applied on a per-class basis. GPUdb supports class breaks based on one
        or more data columns. Distinct values (for strings) or ranges (for
        numeric attributes) must be provided in the cb_column_name1/cb_vals1 and
        cb_column_name2/cb_vals2 parameters. The styling parameters must be
        specified for each class.  All color values must be in the format RRGGBB
        or AARRGGBB (to specify the alpha value).   The image is contained in
        the output parameter *image_data* field."""

        assert isinstance( table_names, (list)), "visualize_image_classbreak(): Argument 'table_names' must be (one) of type(s) '(list)'; given %s" % type( table_names ).__name__
        assert isinstance( world_table_names, (list)), "visualize_image_classbreak(): Argument 'world_table_names' must be (one) of type(s) '(list)'; given %s" % type( world_table_names ).__name__
        assert isinstance( x_column_name, (str, unicode)), "visualize_image_classbreak(): Argument 'x_column_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( x_column_name ).__name__
        assert isinstance( y_column_name, (str, unicode)), "visualize_image_classbreak(): Argument 'y_column_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( y_column_name ).__name__
        assert isinstance( track_ids, (list)), "visualize_image_classbreak(): Argument 'track_ids' must be (one) of type(s) '(list)'; given %s" % type( track_ids ).__name__
        assert isinstance( cb_column_name1, (str, unicode)), "visualize_image_classbreak(): Argument 'cb_column_name1' must be (one) of type(s) '(str, unicode)'; given %s" % type( cb_column_name1 ).__name__
        assert isinstance( cb_vals1, (list)), "visualize_image_classbreak(): Argument 'cb_vals1' must be (one) of type(s) '(list)'; given %s" % type( cb_vals1 ).__name__
        assert isinstance( cb_column_name2, (list)), "visualize_image_classbreak(): Argument 'cb_column_name2' must be (one) of type(s) '(list)'; given %s" % type( cb_column_name2 ).__name__
        assert isinstance( cb_vals2, (list)), "visualize_image_classbreak(): Argument 'cb_vals2' must be (one) of type(s) '(list)'; given %s" % type( cb_vals2 ).__name__
        assert isinstance( min_x, (int, long, float)), "visualize_image_classbreak(): Argument 'min_x' must be (one) of type(s) '(int, long, float)'; given %s" % type( min_x ).__name__
        assert isinstance( max_x, (int, long, float)), "visualize_image_classbreak(): Argument 'max_x' must be (one) of type(s) '(int, long, float)'; given %s" % type( max_x ).__name__
        assert isinstance( min_y, (int, long, float)), "visualize_image_classbreak(): Argument 'min_y' must be (one) of type(s) '(int, long, float)'; given %s" % type( min_y ).__name__
        assert isinstance( max_y, (int, long, float)), "visualize_image_classbreak(): Argument 'max_y' must be (one) of type(s) '(int, long, float)'; given %s" % type( max_y ).__name__
        assert isinstance( width, (int, long, float)), "visualize_image_classbreak(): Argument 'width' must be (one) of type(s) '(int, long, float)'; given %s" % type( width ).__name__
        assert isinstance( height, (int, long, float)), "visualize_image_classbreak(): Argument 'height' must be (one) of type(s) '(int, long, float)'; given %s" % type( height ).__name__
        assert isinstance( projection, (str, unicode)), "visualize_image_classbreak(): Argument 'projection' must be (one) of type(s) '(str, unicode)'; given %s" % type( projection ).__name__
        assert isinstance( bg_color, (int, long, float)), "visualize_image_classbreak(): Argument 'bg_color' must be (one) of type(s) '(int, long, float)'; given %s" % type( bg_color ).__name__
        assert isinstance( do_points, (list)), "visualize_image_classbreak(): Argument 'do_points' must be (one) of type(s) '(list)'; given %s" % type( do_points ).__name__
        assert isinstance( do_shapes, (list)), "visualize_image_classbreak(): Argument 'do_shapes' must be (one) of type(s) '(list)'; given %s" % type( do_shapes ).__name__
        assert isinstance( do_tracks, (list)), "visualize_image_classbreak(): Argument 'do_tracks' must be (one) of type(s) '(list)'; given %s" % type( do_tracks ).__name__
        assert isinstance( do_symbology, (list)), "visualize_image_classbreak(): Argument 'do_symbology' must be (one) of type(s) '(list)'; given %s" % type( do_symbology ).__name__
        assert isinstance( pointcolors, (list)), "visualize_image_classbreak(): Argument 'pointcolors' must be (one) of type(s) '(list)'; given %s" % type( pointcolors ).__name__
        assert isinstance( pointsizes, (list)), "visualize_image_classbreak(): Argument 'pointsizes' must be (one) of type(s) '(list)'; given %s" % type( pointsizes ).__name__
        assert isinstance( pointshapes, (list)), "visualize_image_classbreak(): Argument 'pointshapes' must be (one) of type(s) '(list)'; given %s" % type( pointshapes ).__name__
        assert isinstance( shapelinewidths, (list)), "visualize_image_classbreak(): Argument 'shapelinewidths' must be (one) of type(s) '(list)'; given %s" % type( shapelinewidths ).__name__
        assert isinstance( shapelinecolors, (list)), "visualize_image_classbreak(): Argument 'shapelinecolors' must be (one) of type(s) '(list)'; given %s" % type( shapelinecolors ).__name__
        assert isinstance( shapefillcolors, (list)), "visualize_image_classbreak(): Argument 'shapefillcolors' must be (one) of type(s) '(list)'; given %s" % type( shapefillcolors ).__name__
        assert isinstance( tracklinewidths, (list)), "visualize_image_classbreak(): Argument 'tracklinewidths' must be (one) of type(s) '(list)'; given %s" % type( tracklinewidths ).__name__
        assert isinstance( tracklinecolors, (list)), "visualize_image_classbreak(): Argument 'tracklinecolors' must be (one) of type(s) '(list)'; given %s" % type( tracklinecolors ).__name__
        assert isinstance( trackmarkersizes, (list)), "visualize_image_classbreak(): Argument 'trackmarkersizes' must be (one) of type(s) '(list)'; given %s" % type( trackmarkersizes ).__name__
        assert isinstance( trackmarkercolors, (list)), "visualize_image_classbreak(): Argument 'trackmarkercolors' must be (one) of type(s) '(list)'; given %s" % type( trackmarkercolors ).__name__
        assert isinstance( trackmarkershapes, (list)), "visualize_image_classbreak(): Argument 'trackmarkershapes' must be (one) of type(s) '(list)'; given %s" % type( trackmarkershapes ).__name__
        assert isinstance( trackheadcolors, (list)), "visualize_image_classbreak(): Argument 'trackheadcolors' must be (one) of type(s) '(list)'; given %s" % type( trackheadcolors ).__name__
        assert isinstance( trackheadsizes, (list)), "visualize_image_classbreak(): Argument 'trackheadsizes' must be (one) of type(s) '(list)'; given %s" % type( trackheadsizes ).__name__
        assert isinstance( trackheadshapes, (list)), "visualize_image_classbreak(): Argument 'trackheadshapes' must be (one) of type(s) '(list)'; given %s" % type( trackheadshapes ).__name__
        assert isinstance( options, (dict)), "visualize_image_classbreak(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "visualize_image_classbreak" )

        obj = collections.OrderedDict()
        obj['table_names'] = table_names
        obj['world_table_names'] = world_table_names
        obj['x_column_name'] = x_column_name
        obj['y_column_name'] = y_column_name
        obj['track_ids'] = track_ids
        obj['cb_column_name1'] = cb_column_name1
        obj['cb_vals1'] = cb_vals1
        obj['cb_column_name2'] = cb_column_name2
        obj['cb_vals2'] = cb_vals2
        obj['min_x'] = min_x
        obj['max_x'] = max_x
        obj['min_y'] = min_y
        obj['max_y'] = max_y
        obj['width'] = width
        obj['height'] = height
        obj['projection'] = projection
        obj['bg_color'] = bg_color
        obj['do_points'] = do_points
        obj['do_shapes'] = do_shapes
        obj['do_tracks'] = do_tracks
        obj['do_symbology'] = do_symbology
        obj['pointcolors'] = pointcolors
        obj['pointsizes'] = pointsizes
        obj['pointshapes'] = pointshapes
        obj['shapelinewidths'] = shapelinewidths
        obj['shapelinecolors'] = shapelinecolors
        obj['shapefillcolors'] = shapefillcolors
        obj['tracklinewidths'] = tracklinewidths
        obj['tracklinecolors'] = tracklinecolors
        obj['trackmarkersizes'] = trackmarkersizes
        obj['trackmarkercolors'] = trackmarkercolors
        obj['trackmarkershapes'] = trackmarkershapes
        obj['trackheadcolors'] = trackheadcolors
        obj['trackheadsizes'] = trackheadsizes
        obj['trackheadshapes'] = trackheadshapes
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/visualize/image/classbreak' )
    # end visualize_image_classbreak


    # begin visualize_image_heatmap
    def visualize_image_heatmap( self, table_names = None, x_column_name = None,
                                 y_column_name = None, value_column_name = None,
                                 min_x = None, max_x = None, min_y = None, max_y
                                 = None, width = None, height = None, projection
                                 = 'PLATE_CARREE', colormap = 'none',
                                 blur_radius = '5', bg_color = None,
                                 gradient_start_color = 'FFFFFF',
                                 gradient_end_color = 'FF0000', options = {} ):
        """Generates rasterized heatmap image tiles for an area of interest using the
        given tables and the provided parameters.  All color values must be in
        the format RRGGBB or AARRGGBB (to specify the alpha value).   The
        heatmap image is contained in the output parameter *image_data*
        field."""

        assert isinstance( table_names, (list)), "visualize_image_heatmap(): Argument 'table_names' must be (one) of type(s) '(list)'; given %s" % type( table_names ).__name__
        assert isinstance( x_column_name, (str, unicode)), "visualize_image_heatmap(): Argument 'x_column_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( x_column_name ).__name__
        assert isinstance( y_column_name, (str, unicode)), "visualize_image_heatmap(): Argument 'y_column_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( y_column_name ).__name__
        assert isinstance( value_column_name, (str, unicode)), "visualize_image_heatmap(): Argument 'value_column_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( value_column_name ).__name__
        assert isinstance( min_x, (int, long, float)), "visualize_image_heatmap(): Argument 'min_x' must be (one) of type(s) '(int, long, float)'; given %s" % type( min_x ).__name__
        assert isinstance( max_x, (int, long, float)), "visualize_image_heatmap(): Argument 'max_x' must be (one) of type(s) '(int, long, float)'; given %s" % type( max_x ).__name__
        assert isinstance( min_y, (int, long, float)), "visualize_image_heatmap(): Argument 'min_y' must be (one) of type(s) '(int, long, float)'; given %s" % type( min_y ).__name__
        assert isinstance( max_y, (int, long, float)), "visualize_image_heatmap(): Argument 'max_y' must be (one) of type(s) '(int, long, float)'; given %s" % type( max_y ).__name__
        assert isinstance( width, (int, long, float)), "visualize_image_heatmap(): Argument 'width' must be (one) of type(s) '(int, long, float)'; given %s" % type( width ).__name__
        assert isinstance( height, (int, long, float)), "visualize_image_heatmap(): Argument 'height' must be (one) of type(s) '(int, long, float)'; given %s" % type( height ).__name__
        assert isinstance( projection, (str, unicode)), "visualize_image_heatmap(): Argument 'projection' must be (one) of type(s) '(str, unicode)'; given %s" % type( projection ).__name__
        assert isinstance( colormap, (str, unicode)), "visualize_image_heatmap(): Argument 'colormap' must be (one) of type(s) '(str, unicode)'; given %s" % type( colormap ).__name__
        assert isinstance( blur_radius, (int, long, float)), "visualize_image_heatmap(): Argument 'blur_radius' must be (one) of type(s) '(int, long, float)'; given %s" % type( blur_radius ).__name__
        assert isinstance( bg_color, (int, long, float)), "visualize_image_heatmap(): Argument 'bg_color' must be (one) of type(s) '(int, long, float)'; given %s" % type( bg_color ).__name__
        assert isinstance( gradient_start_color, (int, long, float)), "visualize_image_heatmap(): Argument 'gradient_start_color' must be (one) of type(s) '(int, long, float)'; given %s" % type( gradient_start_color ).__name__
        assert isinstance( gradient_end_color, (int, long, float)), "visualize_image_heatmap(): Argument 'gradient_end_color' must be (one) of type(s) '(int, long, float)'; given %s" % type( gradient_end_color ).__name__
        assert isinstance( options, (dict)), "visualize_image_heatmap(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "visualize_image_heatmap" )

        obj = collections.OrderedDict()
        obj['table_names'] = table_names
        obj['x_column_name'] = x_column_name
        obj['y_column_name'] = y_column_name
        obj['value_column_name'] = value_column_name
        obj['min_x'] = min_x
        obj['max_x'] = max_x
        obj['min_y'] = min_y
        obj['max_y'] = max_y
        obj['width'] = width
        obj['height'] = height
        obj['projection'] = projection
        obj['colormap'] = colormap
        obj['blur_radius'] = blur_radius
        obj['bg_color'] = bg_color
        obj['gradient_start_color'] = gradient_start_color
        obj['gradient_end_color'] = gradient_end_color
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/visualize/image/heatmap' )
    # end visualize_image_heatmap


    # begin visualize_image_heatmap_classbreak
    def visualize_image_heatmap_classbreak( self, table_names = None, x_column_name
                                            = None, y_column_name = None,
                                            cb_column_name = None, cb_vals =
                                            None, cb_ranges = None, min_x =
                                            None, max_x = None, min_y = None,
                                            max_y = None, width = None, height =
                                            None, projection = 'PLATE_CARREE',
                                            colormaps = 'none', blur_radii =
                                            '5', bg_color = None,
                                            gradient_start_colors = 'FFFFFF',
                                            gradient_end_colors = 'FF0000',
                                            options = {} ):
        """Generates 'class break' rasterized heatmap image tiles for an area of
        interest using the given tables and the provided parameters.  A class
        break rendering is where data from one or more GPUdb tables is
        rasterized with styling applied on a per-class basis. GPUdb supports
        class breaks based on one or more data columns. Distinct values (for
        strings) or ranges (for numeric attributes) must be provided in the
        cb_column_name1/cb_vals1 and cb_column_name2/cb_vals2 parameters. The
        styling parameters must be specified for each class.  All color values
        must be in the format RRGGBB or AARRGGBB (to specify the alpha
        value)."""

        assert isinstance( table_names, (list)), "visualize_image_heatmap_classbreak(): Argument 'table_names' must be (one) of type(s) '(list)'; given %s" % type( table_names ).__name__
        assert isinstance( x_column_name, (str, unicode)), "visualize_image_heatmap_classbreak(): Argument 'x_column_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( x_column_name ).__name__
        assert isinstance( y_column_name, (str, unicode)), "visualize_image_heatmap_classbreak(): Argument 'y_column_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( y_column_name ).__name__
        assert isinstance( cb_column_name, (str, unicode)), "visualize_image_heatmap_classbreak(): Argument 'cb_column_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( cb_column_name ).__name__
        assert isinstance( cb_vals, (list)), "visualize_image_heatmap_classbreak(): Argument 'cb_vals' must be (one) of type(s) '(list)'; given %s" % type( cb_vals ).__name__
        assert isinstance( cb_ranges, (list)), "visualize_image_heatmap_classbreak(): Argument 'cb_ranges' must be (one) of type(s) '(list)'; given %s" % type( cb_ranges ).__name__
        assert isinstance( min_x, (int, long, float)), "visualize_image_heatmap_classbreak(): Argument 'min_x' must be (one) of type(s) '(int, long, float)'; given %s" % type( min_x ).__name__
        assert isinstance( max_x, (int, long, float)), "visualize_image_heatmap_classbreak(): Argument 'max_x' must be (one) of type(s) '(int, long, float)'; given %s" % type( max_x ).__name__
        assert isinstance( min_y, (int, long, float)), "visualize_image_heatmap_classbreak(): Argument 'min_y' must be (one) of type(s) '(int, long, float)'; given %s" % type( min_y ).__name__
        assert isinstance( max_y, (int, long, float)), "visualize_image_heatmap_classbreak(): Argument 'max_y' must be (one) of type(s) '(int, long, float)'; given %s" % type( max_y ).__name__
        assert isinstance( width, (int, long, float)), "visualize_image_heatmap_classbreak(): Argument 'width' must be (one) of type(s) '(int, long, float)'; given %s" % type( width ).__name__
        assert isinstance( height, (int, long, float)), "visualize_image_heatmap_classbreak(): Argument 'height' must be (one) of type(s) '(int, long, float)'; given %s" % type( height ).__name__
        assert isinstance( projection, (str, unicode)), "visualize_image_heatmap_classbreak(): Argument 'projection' must be (one) of type(s) '(str, unicode)'; given %s" % type( projection ).__name__
        assert isinstance( colormaps, (list)), "visualize_image_heatmap_classbreak(): Argument 'colormaps' must be (one) of type(s) '(list)'; given %s" % type( colormaps ).__name__
        assert isinstance( blur_radii, (list)), "visualize_image_heatmap_classbreak(): Argument 'blur_radii' must be (one) of type(s) '(list)'; given %s" % type( blur_radii ).__name__
        assert isinstance( bg_color, (int, long, float)), "visualize_image_heatmap_classbreak(): Argument 'bg_color' must be (one) of type(s) '(int, long, float)'; given %s" % type( bg_color ).__name__
        assert isinstance( gradient_start_colors, (list)), "visualize_image_heatmap_classbreak(): Argument 'gradient_start_colors' must be (one) of type(s) '(list)'; given %s" % type( gradient_start_colors ).__name__
        assert isinstance( gradient_end_colors, (list)), "visualize_image_heatmap_classbreak(): Argument 'gradient_end_colors' must be (one) of type(s) '(list)'; given %s" % type( gradient_end_colors ).__name__
        assert isinstance( options, (dict)), "visualize_image_heatmap_classbreak(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "visualize_image_heatmap_classbreak" )

        obj = collections.OrderedDict()
        obj['table_names'] = table_names
        obj['x_column_name'] = x_column_name
        obj['y_column_name'] = y_column_name
        obj['cb_column_name'] = cb_column_name
        obj['cb_vals'] = cb_vals
        obj['cb_ranges'] = cb_ranges
        obj['min_x'] = min_x
        obj['max_x'] = max_x
        obj['min_y'] = min_y
        obj['max_y'] = max_y
        obj['width'] = width
        obj['height'] = height
        obj['projection'] = projection
        obj['colormaps'] = colormaps
        obj['blur_radii'] = blur_radii
        obj['bg_color'] = bg_color
        obj['gradient_start_colors'] = gradient_start_colors
        obj['gradient_end_colors'] = gradient_end_colors
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/visualize/image/heatmap/classbreak' )
    # end visualize_image_heatmap_classbreak


    # begin visualize_image_labels
    def visualize_image_labels( self, table_name = None, x_column_name = None,
                                y_column_name = None, x_offset = None, y_offset
                                = None, text_string = None, font = None,
                                text_color = None, text_angle = None, text_scale
                                = None, draw_box = None, draw_leader = None,
                                line_width = None, line_color = None, fill_color
                                = None, leader_x_column_name = None,
                                leader_y_column_name = None, min_x = None, max_x
                                = None, min_y = None, max_y = None, width =
                                None, height = None, projection =
                                'PLATE_CARREE', options = {} ):
        """Generates a rasterized image tile containing text labels defined by data
        contained in the given table, suitable for overlaying onto a feature
        image tile covering the same area (for example one generated using
        :ref:`visualize_image <visualize_image_python>`).  All color values must
        be integers encoded in the format RRGGBB or AARRGGBB (to specify the
        alpha value) when represented in hexadecimal; although note that literal
        color values must be specified in base 10, not hexadecimal.  Fonts are
        specified as strings of the form 'FAMILY STYLE-OPTIONS SIZE', where
        FAMILY is the font family, STYLE-OPTIONS is a whitespace separated list
        of words defining style, variant, weight, stretch, or gravity, and SIZE
        is a decimal number (size in points) or optionally followed by the unit
        modifier 'px' for absolute size. All three sub-fields are optional;
        default values will be used for omitted sub-fields. (For example,
        'Helvetica Bold Italic 10' specifies Helvetica, Bold and Italic, 10
        points.) A substitute font will be used if a requested font is not
        installed."""

        assert isinstance( table_name, (str, unicode)), "visualize_image_labels(): Argument 'table_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( table_name ).__name__
        assert isinstance( x_column_name, (str, unicode)), "visualize_image_labels(): Argument 'x_column_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( x_column_name ).__name__
        assert isinstance( y_column_name, (str, unicode)), "visualize_image_labels(): Argument 'y_column_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( y_column_name ).__name__
        assert isinstance( x_offset, (str, unicode)), "visualize_image_labels(): Argument 'x_offset' must be (one) of type(s) '(str, unicode)'; given %s" % type( x_offset ).__name__
        assert isinstance( y_offset, (str, unicode)), "visualize_image_labels(): Argument 'y_offset' must be (one) of type(s) '(str, unicode)'; given %s" % type( y_offset ).__name__
        assert isinstance( text_string, (str, unicode)), "visualize_image_labels(): Argument 'text_string' must be (one) of type(s) '(str, unicode)'; given %s" % type( text_string ).__name__
        assert isinstance( font, (str, unicode)), "visualize_image_labels(): Argument 'font' must be (one) of type(s) '(str, unicode)'; given %s" % type( font ).__name__
        assert isinstance( text_color, (str, unicode)), "visualize_image_labels(): Argument 'text_color' must be (one) of type(s) '(str, unicode)'; given %s" % type( text_color ).__name__
        assert isinstance( text_angle, (str, unicode)), "visualize_image_labels(): Argument 'text_angle' must be (one) of type(s) '(str, unicode)'; given %s" % type( text_angle ).__name__
        assert isinstance( text_scale, (str, unicode)), "visualize_image_labels(): Argument 'text_scale' must be (one) of type(s) '(str, unicode)'; given %s" % type( text_scale ).__name__
        assert isinstance( draw_box, (str, unicode)), "visualize_image_labels(): Argument 'draw_box' must be (one) of type(s) '(str, unicode)'; given %s" % type( draw_box ).__name__
        assert isinstance( draw_leader, (str, unicode)), "visualize_image_labels(): Argument 'draw_leader' must be (one) of type(s) '(str, unicode)'; given %s" % type( draw_leader ).__name__
        assert isinstance( line_width, (str, unicode)), "visualize_image_labels(): Argument 'line_width' must be (one) of type(s) '(str, unicode)'; given %s" % type( line_width ).__name__
        assert isinstance( line_color, (str, unicode)), "visualize_image_labels(): Argument 'line_color' must be (one) of type(s) '(str, unicode)'; given %s" % type( line_color ).__name__
        assert isinstance( fill_color, (str, unicode)), "visualize_image_labels(): Argument 'fill_color' must be (one) of type(s) '(str, unicode)'; given %s" % type( fill_color ).__name__
        assert isinstance( leader_x_column_name, (str, unicode)), "visualize_image_labels(): Argument 'leader_x_column_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( leader_x_column_name ).__name__
        assert isinstance( leader_y_column_name, (str, unicode)), "visualize_image_labels(): Argument 'leader_y_column_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( leader_y_column_name ).__name__
        assert isinstance( min_x, (int, long, float)), "visualize_image_labels(): Argument 'min_x' must be (one) of type(s) '(int, long, float)'; given %s" % type( min_x ).__name__
        assert isinstance( max_x, (int, long, float)), "visualize_image_labels(): Argument 'max_x' must be (one) of type(s) '(int, long, float)'; given %s" % type( max_x ).__name__
        assert isinstance( min_y, (int, long, float)), "visualize_image_labels(): Argument 'min_y' must be (one) of type(s) '(int, long, float)'; given %s" % type( min_y ).__name__
        assert isinstance( max_y, (int, long, float)), "visualize_image_labels(): Argument 'max_y' must be (one) of type(s) '(int, long, float)'; given %s" % type( max_y ).__name__
        assert isinstance( width, (int, long, float)), "visualize_image_labels(): Argument 'width' must be (one) of type(s) '(int, long, float)'; given %s" % type( width ).__name__
        assert isinstance( height, (int, long, float)), "visualize_image_labels(): Argument 'height' must be (one) of type(s) '(int, long, float)'; given %s" % type( height ).__name__
        assert isinstance( projection, (str, unicode)), "visualize_image_labels(): Argument 'projection' must be (one) of type(s) '(str, unicode)'; given %s" % type( projection ).__name__
        assert isinstance( options, (dict)), "visualize_image_labels(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "visualize_image_labels" )

        obj = collections.OrderedDict()
        obj['table_name'] = table_name
        obj['x_column_name'] = x_column_name
        obj['y_column_name'] = y_column_name
        obj['x_offset'] = x_offset
        obj['y_offset'] = y_offset
        obj['text_string'] = text_string
        obj['font'] = font
        obj['text_color'] = text_color
        obj['text_angle'] = text_angle
        obj['text_scale'] = text_scale
        obj['draw_box'] = draw_box
        obj['draw_leader'] = draw_leader
        obj['line_width'] = line_width
        obj['line_color'] = line_color
        obj['fill_color'] = fill_color
        obj['leader_x_column_name'] = leader_x_column_name
        obj['leader_y_column_name'] = leader_y_column_name
        obj['min_x'] = min_x
        obj['max_x'] = max_x
        obj['min_y'] = min_y
        obj['max_y'] = max_y
        obj['width'] = width
        obj['height'] = height
        obj['projection'] = projection
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/visualize/image/labels' )
    # end visualize_image_labels


    # begin visualize_video
    def visualize_video( self, table_names = None, world_table_names = None,
                         track_ids = None, x_column_name = None, y_column_name =
                         None, min_x = None, max_x = None, min_y = None, max_y =
                         None, width = None, height = None, projection =
                         'PLATE_CARREE', bg_color = None, do_points = 'true',
                         do_shapes = 'true', do_tracks = 'true', pointcolors =
                         'FF0000', pointsizes = '3', pointshapes = None,
                         shapelinewidths = '3', shapelinecolors = 'FFFF00 ',
                         shapefillcolors = '-1', tracklinewidths = '3',
                         tracklinecolors = 'green', trackmarkersizes = '3',
                         trackmarkercolors = '0000FF', trackmarkershapes =
                         'none', trackheadcolors = 'FFFFFF', trackheadsizes =
                         '10', trackheadshapes = 'circle', time_intervals =
                         None, video_style = None, session_key = None, options =
                         {} ):
        """Creates raster images of data in the given table based on provided input
        parameters. Numerous parameters are required to call this function. Some
        of the important parameters are the attributes of the generated images
        (input parameter *bg_color*, input parameter *width*, @{input height{),
        the collection of GPUdb table names on which this function is to be
        applied, for which shapes (point, polygon, tracks) the images are to be
        created and a user specified session key. This session key is later used
        to fetch the generated images stored by GPUdb. The operation is
        synchronous meaning that GPUdb will not return the request until the
        images for all the frames of the video are fully available.  Once the
        request has been processed then the generated video frames are available
        for download via WMS using STYLES=cached. In this request the LAYERS
        parameter should be populated with the session key passed in input
        parameter *session_key* of the visualize video request and the FRAME
        parameter indicates which 0-based frame of the video should be returned.
        All other WMS parameters are ignored for this mode.  For instance, if a
        20 frame video with the session key 'MY-SESSION-KEY' was generated, the
        first frame could be retrieved with the URL::       http://<gpudb-ip-
        address>:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS=MY-SESSION-
        KEY&FRAME=0  and the last frame could be retrieved with::      http
        ://gpudb-ip-address:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS=MY-
        SESSION-KEY&FRAME=19     The response payload provides, among other
        things, the number of frames which were created by GPUdb."""

        assert isinstance( table_names, (list)), "visualize_video(): Argument 'table_names' must be (one) of type(s) '(list)'; given %s" % type( table_names ).__name__
        assert isinstance( world_table_names, (list)), "visualize_video(): Argument 'world_table_names' must be (one) of type(s) '(list)'; given %s" % type( world_table_names ).__name__
        assert isinstance( track_ids, (list)), "visualize_video(): Argument 'track_ids' must be (one) of type(s) '(list)'; given %s" % type( track_ids ).__name__
        assert isinstance( x_column_name, (str, unicode)), "visualize_video(): Argument 'x_column_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( x_column_name ).__name__
        assert isinstance( y_column_name, (str, unicode)), "visualize_video(): Argument 'y_column_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( y_column_name ).__name__
        assert isinstance( min_x, (int, long, float)), "visualize_video(): Argument 'min_x' must be (one) of type(s) '(int, long, float)'; given %s" % type( min_x ).__name__
        assert isinstance( max_x, (int, long, float)), "visualize_video(): Argument 'max_x' must be (one) of type(s) '(int, long, float)'; given %s" % type( max_x ).__name__
        assert isinstance( min_y, (int, long, float)), "visualize_video(): Argument 'min_y' must be (one) of type(s) '(int, long, float)'; given %s" % type( min_y ).__name__
        assert isinstance( max_y, (int, long, float)), "visualize_video(): Argument 'max_y' must be (one) of type(s) '(int, long, float)'; given %s" % type( max_y ).__name__
        assert isinstance( width, (int, long, float)), "visualize_video(): Argument 'width' must be (one) of type(s) '(int, long, float)'; given %s" % type( width ).__name__
        assert isinstance( height, (int, long, float)), "visualize_video(): Argument 'height' must be (one) of type(s) '(int, long, float)'; given %s" % type( height ).__name__
        assert isinstance( projection, (str, unicode)), "visualize_video(): Argument 'projection' must be (one) of type(s) '(str, unicode)'; given %s" % type( projection ).__name__
        assert isinstance( bg_color, (int, long, float)), "visualize_video(): Argument 'bg_color' must be (one) of type(s) '(int, long, float)'; given %s" % type( bg_color ).__name__
        assert isinstance( do_points, (list)), "visualize_video(): Argument 'do_points' must be (one) of type(s) '(list)'; given %s" % type( do_points ).__name__
        assert isinstance( do_shapes, (list)), "visualize_video(): Argument 'do_shapes' must be (one) of type(s) '(list)'; given %s" % type( do_shapes ).__name__
        assert isinstance( do_tracks, (list)), "visualize_video(): Argument 'do_tracks' must be (one) of type(s) '(list)'; given %s" % type( do_tracks ).__name__
        assert isinstance( pointcolors, (list)), "visualize_video(): Argument 'pointcolors' must be (one) of type(s) '(list)'; given %s" % type( pointcolors ).__name__
        assert isinstance( pointsizes, (list)), "visualize_video(): Argument 'pointsizes' must be (one) of type(s) '(list)'; given %s" % type( pointsizes ).__name__
        assert isinstance( pointshapes, (list)), "visualize_video(): Argument 'pointshapes' must be (one) of type(s) '(list)'; given %s" % type( pointshapes ).__name__
        assert isinstance( shapelinewidths, (list)), "visualize_video(): Argument 'shapelinewidths' must be (one) of type(s) '(list)'; given %s" % type( shapelinewidths ).__name__
        assert isinstance( shapelinecolors, (list)), "visualize_video(): Argument 'shapelinecolors' must be (one) of type(s) '(list)'; given %s" % type( shapelinecolors ).__name__
        assert isinstance( shapefillcolors, (list)), "visualize_video(): Argument 'shapefillcolors' must be (one) of type(s) '(list)'; given %s" % type( shapefillcolors ).__name__
        assert isinstance( tracklinewidths, (list)), "visualize_video(): Argument 'tracklinewidths' must be (one) of type(s) '(list)'; given %s" % type( tracklinewidths ).__name__
        assert isinstance( tracklinecolors, (list)), "visualize_video(): Argument 'tracklinecolors' must be (one) of type(s) '(list)'; given %s" % type( tracklinecolors ).__name__
        assert isinstance( trackmarkersizes, (list)), "visualize_video(): Argument 'trackmarkersizes' must be (one) of type(s) '(list)'; given %s" % type( trackmarkersizes ).__name__
        assert isinstance( trackmarkercolors, (list)), "visualize_video(): Argument 'trackmarkercolors' must be (one) of type(s) '(list)'; given %s" % type( trackmarkercolors ).__name__
        assert isinstance( trackmarkershapes, (list)), "visualize_video(): Argument 'trackmarkershapes' must be (one) of type(s) '(list)'; given %s" % type( trackmarkershapes ).__name__
        assert isinstance( trackheadcolors, (list)), "visualize_video(): Argument 'trackheadcolors' must be (one) of type(s) '(list)'; given %s" % type( trackheadcolors ).__name__
        assert isinstance( trackheadsizes, (list)), "visualize_video(): Argument 'trackheadsizes' must be (one) of type(s) '(list)'; given %s" % type( trackheadsizes ).__name__
        assert isinstance( trackheadshapes, (list)), "visualize_video(): Argument 'trackheadshapes' must be (one) of type(s) '(list)'; given %s" % type( trackheadshapes ).__name__
        assert isinstance( time_intervals, (list)), "visualize_video(): Argument 'time_intervals' must be (one) of type(s) '(list)'; given %s" % type( time_intervals ).__name__
        assert isinstance( video_style, (str, unicode)), "visualize_video(): Argument 'video_style' must be (one) of type(s) '(str, unicode)'; given %s" % type( video_style ).__name__
        assert isinstance( session_key, (str, unicode)), "visualize_video(): Argument 'session_key' must be (one) of type(s) '(str, unicode)'; given %s" % type( session_key ).__name__
        assert isinstance( options, (dict)), "visualize_video(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "visualize_video" )

        obj = collections.OrderedDict()
        obj['table_names'] = table_names
        obj['world_table_names'] = world_table_names
        obj['track_ids'] = track_ids
        obj['x_column_name'] = x_column_name
        obj['y_column_name'] = y_column_name
        obj['min_x'] = min_x
        obj['max_x'] = max_x
        obj['min_y'] = min_y
        obj['max_y'] = max_y
        obj['width'] = width
        obj['height'] = height
        obj['projection'] = projection
        obj['bg_color'] = bg_color
        obj['do_points'] = do_points
        obj['do_shapes'] = do_shapes
        obj['do_tracks'] = do_tracks
        obj['pointcolors'] = pointcolors
        obj['pointsizes'] = pointsizes
        obj['pointshapes'] = pointshapes
        obj['shapelinewidths'] = shapelinewidths
        obj['shapelinecolors'] = shapelinecolors
        obj['shapefillcolors'] = shapefillcolors
        obj['tracklinewidths'] = tracklinewidths
        obj['tracklinecolors'] = tracklinecolors
        obj['trackmarkersizes'] = trackmarkersizes
        obj['trackmarkercolors'] = trackmarkercolors
        obj['trackmarkershapes'] = trackmarkershapes
        obj['trackheadcolors'] = trackheadcolors
        obj['trackheadsizes'] = trackheadsizes
        obj['trackheadshapes'] = trackheadshapes
        obj['time_intervals'] = time_intervals
        obj['video_style'] = video_style
        obj['session_key'] = session_key
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/visualize/video' )
    # end visualize_video


    # begin visualize_video_heatmap
    def visualize_video_heatmap( self, table_names = None, x_column_name = None,
                                 y_column_name = None, min_x = None, max_x =
                                 None, min_y = None, max_y = None,
                                 time_intervals = None, width = None, height =
                                 None, projection = 'PLATE_CARREE', bg_color =
                                 None, colormap = 'none', blur_radius = '5',
                                 gradient_start_color = 'FFFFFF',
                                 gradient_end_color = 'FF0000', video_style =
                                 None, session_key = None, options = {} ):
        """Creates raster heat-map images of table data based on input parameters.
        Numerous parameters are required to call this function. Some of the
        important parameters are the attributes of the generated images (input
        parameter *bg_color*, input parameter *width*, input parameter
        *height*), the collection of GPUdb table names on which this function is
        to be applied and a user specified session key. This session key is
        later used to fetch the generated images stored by GPUdb. The operation
        is synchronous meaning that GPUdb will not return the request until all
        the images are fully available.  Once the request has been processed
        then the generated video frames are available for download via WMS using
        STYLES=cached. In this request the LAYERS parameter should be populated
        with the session key passed in input parameter *session_key* of the
        visualize video request and the FRAME parameter indicates which 0-based
        frame of the video should be returned. All other WMS parameters are
        ignored for this mode.  For instance, if a 20 frame video with the
        session key 'MY-SESSION-KEY' was generated, the first frame could be
        retrieved with the URL::       http://<gpudb-ip-
        address>:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS=MY-SESSION-
        KEY&FRAME=0  and the last frame could be retrieved with::      http
        ://gpudb-ip-address:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS=MY-
        SESSION-KEY&FRAME=19     The response payload provides among other
        things the number of frames which were created by GPUdb."""

        assert isinstance( table_names, (list)), "visualize_video_heatmap(): Argument 'table_names' must be (one) of type(s) '(list)'; given %s" % type( table_names ).__name__
        assert isinstance( x_column_name, (str, unicode)), "visualize_video_heatmap(): Argument 'x_column_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( x_column_name ).__name__
        assert isinstance( y_column_name, (str, unicode)), "visualize_video_heatmap(): Argument 'y_column_name' must be (one) of type(s) '(str, unicode)'; given %s" % type( y_column_name ).__name__
        assert isinstance( min_x, (int, long, float)), "visualize_video_heatmap(): Argument 'min_x' must be (one) of type(s) '(int, long, float)'; given %s" % type( min_x ).__name__
        assert isinstance( max_x, (int, long, float)), "visualize_video_heatmap(): Argument 'max_x' must be (one) of type(s) '(int, long, float)'; given %s" % type( max_x ).__name__
        assert isinstance( min_y, (int, long, float)), "visualize_video_heatmap(): Argument 'min_y' must be (one) of type(s) '(int, long, float)'; given %s" % type( min_y ).__name__
        assert isinstance( max_y, (int, long, float)), "visualize_video_heatmap(): Argument 'max_y' must be (one) of type(s) '(int, long, float)'; given %s" % type( max_y ).__name__
        assert isinstance( time_intervals, (list)), "visualize_video_heatmap(): Argument 'time_intervals' must be (one) of type(s) '(list)'; given %s" % type( time_intervals ).__name__
        assert isinstance( width, (int, long, float)), "visualize_video_heatmap(): Argument 'width' must be (one) of type(s) '(int, long, float)'; given %s" % type( width ).__name__
        assert isinstance( height, (int, long, float)), "visualize_video_heatmap(): Argument 'height' must be (one) of type(s) '(int, long, float)'; given %s" % type( height ).__name__
        assert isinstance( projection, (str, unicode)), "visualize_video_heatmap(): Argument 'projection' must be (one) of type(s) '(str, unicode)'; given %s" % type( projection ).__name__
        assert isinstance( bg_color, (int, long, float)), "visualize_video_heatmap(): Argument 'bg_color' must be (one) of type(s) '(int, long, float)'; given %s" % type( bg_color ).__name__
        assert isinstance( colormap, (str, unicode)), "visualize_video_heatmap(): Argument 'colormap' must be (one) of type(s) '(str, unicode)'; given %s" % type( colormap ).__name__
        assert isinstance( blur_radius, (int, long, float)), "visualize_video_heatmap(): Argument 'blur_radius' must be (one) of type(s) '(int, long, float)'; given %s" % type( blur_radius ).__name__
        assert isinstance( gradient_start_color, (int, long, float)), "visualize_video_heatmap(): Argument 'gradient_start_color' must be (one) of type(s) '(int, long, float)'; given %s" % type( gradient_start_color ).__name__
        assert isinstance( gradient_end_color, (int, long, float)), "visualize_video_heatmap(): Argument 'gradient_end_color' must be (one) of type(s) '(int, long, float)'; given %s" % type( gradient_end_color ).__name__
        assert isinstance( video_style, (str, unicode)), "visualize_video_heatmap(): Argument 'video_style' must be (one) of type(s) '(str, unicode)'; given %s" % type( video_style ).__name__
        assert isinstance( session_key, (str, unicode)), "visualize_video_heatmap(): Argument 'session_key' must be (one) of type(s) '(str, unicode)'; given %s" % type( session_key ).__name__
        assert isinstance( options, (dict)), "visualize_video_heatmap(): Argument 'options' must be (one) of type(s) '(dict)'; given %s" % type( options ).__name__

        (REQ_SCHEMA, REP_SCHEMA) = self.get_schemas( "visualize_video_heatmap" )

        obj = collections.OrderedDict()
        obj['table_names'] = table_names
        obj['x_column_name'] = x_column_name
        obj['y_column_name'] = y_column_name
        obj['min_x'] = min_x
        obj['max_x'] = max_x
        obj['min_y'] = min_y
        obj['max_y'] = max_y
        obj['time_intervals'] = time_intervals
        obj['width'] = width
        obj['height'] = height
        obj['projection'] = projection
        obj['bg_color'] = bg_color
        obj['colormap'] = colormap
        obj['blur_radius'] = blur_radius
        obj['gradient_start_color'] = gradient_start_color
        obj['gradient_end_color'] = gradient_end_color
        obj['video_style'] = video_style
        obj['session_key'] = session_key
        obj['options'] = options

        return self.post_then_get( REQ_SCHEMA, REP_SCHEMA, obj, '/visualize/video/heatmap' )
    # end visualize_video_heatmap


    # @end_autogen 


    # -----------------------------------------------------------------------
    # End autogenerated functions
    # -----------------------------------------------------------------------


# end class GPUdb


